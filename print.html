<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZAFU ACM Wiki</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
main p > code {
    color: #f14668 !important;
    background: unset  !important;
}

main pre > code {
    padding: 10px !important;
}

main p a, main ul a {
    color: #0099ff !important;
}

.katex-display {
    overflow: auto hidden;
}
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {

        delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true },
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
        ],
        macros: {
            "\\RR": "\\mathbb{R}",
            "\\NN": "\\mathbb{N}",
            "\\QQ": "\\mathbb{Q}",
            "\\ZZ": "\\mathbb{Z}",
            "\\CC": "\\mathbb{C}",
            "\\ee": "\\mathrm{e}",
            "\\dd": "\\mathrm{d}",
            "\\eps": "\\varepsilon",
        },
        globalGroup: true,
        throwOnError: false
    });
});
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="docs/_static/extra.css">
        <link rel="stylesheet" href="theme/mdbook/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="about/support.html"><strong aria-hidden="true">1.1.</strong> 如何参与</a></li></ol></li><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">2.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/basic.html"><strong aria-hidden="true">2.1.</strong> 算法思想</a></li><li class="chapter-item "><a href="basic/example.html"><strong aria-hidden="true">2.2.</strong> 优化例题</a></li><li class="chapter-item "><a href="basic/divide.html"><strong aria-hidden="true">2.3.</strong> 递归</a></li><li class="chapter-item "><a href="basic/binary.html"><strong aria-hidden="true">2.4.</strong> 二分</a></li><li class="chapter-item "><a href="basic/greedy.html"><strong aria-hidden="true">2.5.</strong> 贪心</a></li><li class="chapter-item "><a href="basic/sort.html"><strong aria-hidden="true">2.6.</strong> 排序</a></li><li class="chapter-item "><a href="basic/recursion.html"><strong aria-hidden="true">2.7.</strong> 递推初步</a></li><li class="chapter-item "><a href="basic/dp.html"><strong aria-hidden="true">2.8.</strong> 动态规划</a></li><li class="chapter-item "><a href="basic/prefix-sum.html"><strong aria-hidden="true">2.9.</strong> 前缀和 & 差分</a></li><li class="chapter-item "><a href="basic/quick-pow.html"><strong aria-hidden="true">2.10.</strong> 快速幂</a></li><li class="chapter-item "><a href="basic/end.html"><strong aria-hidden="true">2.11.</strong> 结语</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">3.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/sieve.html"><strong aria-hidden="true">3.1.</strong> 筛法</a></li><li class="chapter-item "><a href="math/crt.html"><strong aria-hidden="true">3.2.</strong> 中国剩余定理</a></li><li class="chapter-item "><a href="math/game-theory.html"><strong aria-hidden="true">3.3.</strong> 基础博弈</a></li><li class="chapter-item "><a href="math/dirichlet.html"><strong aria-hidden="true">3.4.</strong> Dirichlet 卷积</a></li><li class="chapter-item "><a href="math/poly/index.html"><strong aria-hidden="true">3.5.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/poly/convolution.html"><strong aria-hidden="true">3.5.1.</strong> 卷积</a></li><li class="chapter-item "><a href="math/poly/fft.html"><strong aria-hidden="true">3.5.2.</strong> FFT</a></li><li class="chapter-item "><a href="math/poly/newton.html"><strong aria-hidden="true">3.5.3.</strong> 牛顿迭代</a></li></ol></li><li class="chapter-item "><a href="math/multiplicative-function/index.html"><strong aria-hidden="true">3.6.</strong> 积性函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/multiplicative-function/min25.html"><strong aria-hidden="true">3.6.1.</strong> Min_25 筛法</a></li><li class="chapter-item "><a href="math/multiplicative-function/zhouge.html"><strong aria-hidden="true">3.6.2.</strong> 州阁筛</a></li><li class="chapter-item "><a href="math/multiplicative-function/pn.html"><strong aria-hidden="true">3.6.3.</strong> Powerful Number 筛</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="struct/index.html"><strong aria-hidden="true">4.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="struct/fenwick-tree.html"><strong aria-hidden="true">4.1.</strong> 数据结构</a></li><li class="chapter-item "><a href="struct/sparse-table.html"><strong aria-hidden="true">4.2.</strong> ST 表</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">5.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="string/minimal-string.html"><strong aria-hidden="true">5.1.</strong> 最小表示法</a></li></ol></li><li class="chapter-item expanded "><a href="other/index.html"><strong aria-hidden="true">6.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="other/markdown.html"><strong aria-hidden="true">6.1.</strong> Markdown 简介</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZAFU ACM Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zafuacm/wiki/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>校队自用 Wiki。本网页部署于 GitHub Page，您也可以一同修改。</p>
<h2 id="why"><a class="header" href="#why">Why</a></h2>
<p>因为网上的资料过于杂乱，我希望能整理一些更有可读性的文章，让资料更有价值，让知识更有序。</p>
<p>也有很多大型项目在干同样的事情，如 <a href="https://oi-wiki.org">OI-Wiki</a>，虽然文章质量很高但是并不容易读懂（我太菜了）。毕竟大学才开始接触编程，需要更低的门槛。</p>
<p>我更期望这里文档具有线性可读性，能够像一本书一样顺序的学习，因此我加入了 MdBook 支持，这也意味着表达形式会受到限制。</p>
<p><span style="float: right;">by <a href="https://github.com/rogeryoungh">@rogeryoungh</a></span></p>
<h2 id="贡献"><a class="header" href="#贡献">贡献</a></h2>
<p>如果您对参与编写感兴趣，只需点击标题右边的编辑按钮，即可编辑。更详细的编写流程请阅读 <a href="about/support.html">如何参与</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何参与"><a class="header" href="#如何参与">如何参与</a></h1>
<p>欢迎大家对本文档进行贡献。</p>
<p>包括且不限于</p>
<ul>
<li>修正错误，补充代码。</li>
<li>添加更详细的描述。</li>
<li>增加新想法。</li>
</ul>
<p>请您在撰稿或者修正以前，仔细阅读以下内容，以帮助您完成更高质量的内容。</p>
<p>需要了解一些 Markdown 的知识，请查看 <a href="about/../other/markdown.html">Markdown</a>。</p>
<h2 id="我之前没怎么用过-github"><a class="header" href="#我之前没怎么用过-github">我之前没怎么用过 GitHub</a></h2>
<p>你也可以直接发文本给我，由我手动合并，但这样你并不会得到 contribute。</p>
<p>首先你需要有一个 GitHub 帐号，但不需要高超的 GitHub 技巧。</p>
<ol>
<li>点击标题右边的编辑按钮，开始编辑。</li>
<li>在编辑框里进行修改。由于 MkDocs 支持一些扩展 Markdown，它不一定能在 GitHub 的预览里很好的展示。</li>
<li>写好了之后点下方的绿色按钮 Propose changes 提交修改。但是，GitHub 可能会提示你没有权限。不必担心！GitHub 会自动帮你将 本项目 的所有文件复制一份，放到你的仓库中（fork）并创建申请合并更改的请求 (Pull Request)；</li>
<li>之后，点上方的绿色按钮 (Create pull request) 后，GitHub 会跳转到一个新的页面 Open a pull request。删掉方框里的文字，简单写写你做的修改，然后再点一下下面的绿色按钮 (Create pull request)；</li>
<li>不出意外的话，你的 PR 就顺利提交到仓库，等待合并了。之后，你就可以等待项目组合并你的分支，或者指出还要修改的地方。当然，你也可以给他人的 PR 提出修改意见，或者只是点赞/踩。如果有消息，会有邮件通知和/或出现在网页右上角的提醒（取决于你个人 Settings 中的设置）。</li>
</ol>
<p>在你的分支被合并 (merge) 到主分支 (main) 之前，你对 本项目 所做的任何修改都不会出现在页面上。所以请不用担心“你的编辑会破坏网页正在显示的页面”一事。</p>
<h2 id="我之前用过-github"><a class="header" href="#我之前用过-github">我之前用过 GitHub</a></h2>
<p>大胆写吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<p>一些名词的意义是自明的，比如模拟、搜索等，这些词就不再详加解释了。</p>
<h2 id="序"><a class="header" href="#序">序</a></h2>
<p>语言只是工具，如果没有好的算法，也无法解决问题。这里会介绍一些基本的算法知识。</p>
<p>我挑选了一点题目，在每页的最下面。全部见 <a href="https://www.luogu.com.cn/training/70190">题目列表汇总</a>。</p>
<p>部分内容来自于 <a href="https://oi-wiki.org/">OI-Wiki</a>，那里也有许多算法的介绍，感兴趣的可以看看。</p>
<h2 id="试机题"><a class="header" href="#试机题">试机题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1001">P1001 A+B Problem</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1047">P1047 校门外的树</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2181">P2181 对角线</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法思想"><a class="header" href="#算法思想">算法思想</a></h1>
<p>这里罗列了一些基本思想，可能较为抽象，可以反复回来看。</p>
<p>抽象的理解“分治”、“贪心”等算法可能有一定难度，我还准备了一些例题来帮助思考。</p>
<h2 id="枚举"><a class="header" href="#枚举">枚举</a></h2>
<p>即从所有的可能的解中一一测试，判断题目的条件是否成立。</p>
<p>枚举的关键：枚举空间，枚举顺序。</p>
<p>显然问题的可能的解空间不能太大，否则无法在规定的时间内完成，因此要尽量减小枚举的范围。</p>
<p>枚举的顺序也很重要，比如求最后一个满足条件的数，自然是从后往前枚举。</p>
<p>常常使用搜索来实现枚举。</p>
<h2 id="模拟"><a class="header" href="#模拟">模拟</a></h2>
<p>用代码模拟题目中要求的操作。</p>
<p>模拟题目通常具有码量大、操作多、思路繁复的特点，非常考验码力。</p>
<h2 id="分治"><a class="header" href="#分治">分治</a></h2>
<p>即分而治之，将一个大的问题划分成规模较小的子问题。大致可分成三步</p>
<ol>
<li>分解：将原问题分解为多个类似的子问题。</li>
<li>解决：反复分解，直到子问题可以被直接解决。</li>
<li>合并：将子问题的解合并成原问题的解。</li>
</ol>
<p>分治法能解决的问题一般有以下特征：</p>
<ul>
<li>该问题的规模较小时可以被容易的解决。</li>
<li>子问题的解可以合并为原问题的解。</li>
</ul>
<p>常用的实现分治的方法有递归、递推、动态规划、搜索等，灵活多变。</p>
<h2 id="贪心"><a class="header" href="#贪心">贪心</a></h2>
<p>贪心算法，是用计算机来模拟一个“贪心”的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。</p>
<p>可想而知，只有在特定的问题下，贪心法才能获得最优解。因此使用贪心法时，要确保自己能证明其正确性。</p>
<p>贪心算法常见的有两种证明方法：</p>
<ol>
<li>反证法：交换两个元素后答案不会更好，那么可以确定当前的算法是最优解了。</li>
<li>归纳法：通过归纳证明答案是最优解。</li>
</ol>
<h2 id="预处理"><a class="header" href="#预处理">预处理</a></h2>
<p>提前计算一些可能用到的数据，这样会避免每次计算带来的额外开销。</p>
<p>有时也叫打表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优化例题"><a class="header" href="#优化例题">优化例题</a></h1>
<h2 id="ccf-1034-钞票兑换--枚举优化"><a class="header" href="#ccf-1034-钞票兑换--枚举优化">CCF 1034 钞票兑换 · 枚举优化</a></h2>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/U160446">CCF 1034 钞票兑换</a>。</p>
<p>题目大意：将任意给定的整百元钞票，兑换成10元、20元、50元小钞票形式。输出兑换方案总数。</p>
<p>数据范围：输入需要兑换的钞票总数 $n$， $100 \leqslant n \leqslant 1.7 \times 10^{11}$</p>
<h3 id="思路-0"><a class="header" href="#思路-0">思路 0</a></h3>
<p>简单起见，记兑换得到 $10$ 元 $a$ 张，$20$ 元 $b$ 张，$50$ 元 $c$ 张，并记 $n=100k$。</p>
<p>只需测试 $10a+20b+50c = 100k$，暴力是显然的。</p>
<pre><code class="language-cpp">for (int c = 0; c &lt;= n/50; c++) {
    for (int b = 0; b &lt;= n/20; b++) {
        for (int a = 0; a &lt;= n/10; a++) {
            if (a*10 + b*20 + c*50 == n)
                sum++;
        }
    }
}
</code></pre>
<h3 id="优化-1"><a class="header" href="#优化-1">优化 1</a></h3>
<p>注意到 $a = 10k - 5c - 2b$，即当 $b,c$ 确定时可以计算出 $a$，判断是否 $a \geqslant 0$ 即可。</p>
<p>如此可以消掉一层循环。</p>
<pre><code class="language-cpp">for (int c = 0; c &lt;= n/50; c++) {
    for (int b = 0; b &lt;= n/20; b++) {
        if(n/10 - 5*c - 2*b &gt;= 0)
            sum++;
    }
}
</code></pre>
<h3 id="优化-2"><a class="header" href="#优化-2">优化 2</a></h3>
<p>对 $a \geqslant 0$ 求解，得到 $b \leqslant 5k-2.5c$。因此 $b$ 是 $[0,5k-2.5c]$ 之间的整数，又消掉一层。</p>
<pre><code class="language-cpp">for (int c = 0; c &lt;= n/50; c++) {
    sum += (n - 50 * c) / 20 + 1;
}
</code></pre>
<h3 id="优化-3"><a class="header" href="#优化-3">优化 3</a></h3>
<p>优化 2 中我们得到了一个求和式，其实可以对求和式直接计算。提出首项</p>
<p>$$
\sum_{i=0}^{2k}\left(\lfloor 5k-2.5i \rfloor + 1\right)
= 5k + \sum_{i=1}^{2k}\lfloor 5k-2.5i \rfloor + 2k
$$</p>
<p>分奇偶展开有</p>
<p>$$
\begin{aligned}
\sum_{i=1}^{2k}\lfloor 5k-2.5i \rfloor
&amp;= \sum_{i=1}^{k}\lfloor 5k-2.5(2i-1) \rfloor + \sum_{i=1}^{k}\lfloor 5k-2.5(2i) \rfloor \\
&amp;= \sum_{i=1}^{k}(10k-10i+2) = 5k^2 -3k + 1
\end{aligned}
$$</p>
<p>于是可以写出代码</p>
<pre><code class="language-cpp">sum = (5 * k + 4) * k + 1;
</code></pre>
<div id="admonition-提示" class="admonition info">
<div class="admonition-title">
<p>提示</p>
<p><a class="admonition-anchor-link" href="basic/example.html#admonition-提示"></a></p>
</div>
<div>
<p>直接抄是过不了题的，观察一下数据范围。有时候拿不了全分，也要争取部分分。</p>
</div>
</div>
<p>三思而后行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="递归"><a class="header" href="#递归">递归</a></h1>
<p>递归是分治思想的一个应用，是一种编程技巧。</p>
<p>归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。</p>
<p>递归一般包含两个条件，结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。</p>
<h2 id="举例"><a class="header" href="#举例">举例</a></h2>
<blockquote>
<p>要理解递归，就得先理解什么是递归。</p>
</blockquote>
<p>递归在数学中非常常见。例如，自然数的定义（Peano 公理）：$0$ 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。</p>
<p>理解递归，我们只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的，不必跳进这个函数里面企图探究更多细节。</p>
<p>假如我们要计算阶乘，初始值 $f(1) = 1$，且 </p>
<p>$$
f(n) = nf(n-1)
$$</p>
<p>于是</p>
<pre><code class="language-cpp">int f(int n) {
    if (n == 1)
        return 1;
    return n * f(n - 1);
}
</code></pre>
<p>假如我们要计算 Fibonacci 数列，初始值 $f(1) = f(2) = 1$，且</p>
<p>$$
f(n) = f(n-1) + f(n-2)
$$</p>
<p>于是</p>
<pre><code class="language-cpp">int f(int n) {
    if (n &lt;= 2)
        return 1;
    return f(n) + f(n - 1);
}
</code></pre>
<p>递归有很多优点，结构清晰，可读性强。</p>
<h2 id="递归的缺点"><a class="header" href="#递归的缺点">递归的缺点</a></h2>
<p>在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 <strong>栈溢出</strong> 的后果。</p>
<p>因为栈本身存在额外的开销，而循环没有。初级的递归实现可能会因为递归次数太多，容易超时。这时需要对递归进行优化，或者尝试非递归解法。</p>
<h2 id="记忆化"><a class="header" href="#记忆化">记忆化</a></h2>
<p>递归计算阶乘还不太慢，但假若计算的是 Fibonacci 数列第 $100$ 项，可能就等不到输出了。</p>
<p>究其根本，时间主要消耗在重复计算上，展开几次递归就会发现重复计算了很多的数据。</p>
<p>是否可以记忆每一次计算的值，等后面用的时候再用呢？</p>
<pre><code class="language-cpp">int fib[MAXN], vis[MAXN];

int f(int n) {
    if (n &lt;= 2)
        return 1;
    if (!vis[n]) {
        fib[n] = f(n - 1) + f(n - 2);
        vis[n] = 1;
    }
    return fib[n];
}
</code></pre>
<p>我们增加了 <code>vis</code> 数组，用来标志 $f(n)$ 是否计算过，如果没有计算过才去计算它，若计算过就直接返回。</p>
<h2 id="回溯法"><a class="header" href="#回溯法">回溯法</a></h2>
<p>回溯就不讲了，想了解的自己看吧。<a href="https://oi-wiki.org/search/backtracking/">Link</a></p>
<h2 id="例题"><a class="header" href="#例题">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2089">P2089 烤鸡</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1464">P1464 Function</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>二分查找比较基础，这里我就讲的简略一点。</p>
<h2 id="算法思想-1"><a class="header" href="#算法思想-1">算法思想</a></h2>
<p>对于有序的数组，查找一个元素如果还是线性查找，实在是太浪费了。</p>
<p>假设数组 $a$ 递增，设查找区间是 $[l,r]$，被查找元素是 $x$。</p>
<p>取查找范围的中间值 $m = \dfrac{l+r}{2}$。</p>
<ul>
<li>如果 $a_m \geqslant x$，说明 $x$ 会在 $[l,m]$ 范围</li>
<li>否则 $x$ 会在 $[m,r]$。</li>
</ul>
<p>如此反复。</p>
<pre><code class="language-cpp">while (l &lt; r) {
    int mid = (l + r) / 2;
    if (aa[mid] &gt;= x)
        r = mid;
    else
        l = mid + 1;
}
return l;
</code></pre>
<p>确切的说，上述代码实现的是：在单增数组中查找 $\geqslant x$ 的数中最前的一个。</p>
<p>类似的，还有：在单减数组中查找 $\geqslant x$ 的数中最后的一个。</p>
<pre><code class="language-cpp">while (l &lt; r) {
    int mid = (l + r + 1) / 2;
    if (aa[mid] &gt;= x)
        l = mid;
    else
        r = mid - 1;
}
return l;
</code></pre>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>对于单调的函数，也可以通过二分查找查找其符合条件的值。</p>
<p>有时需要转换思考角度，比如 <a href="https://www.luogu.com.cn/problem/P1873">P1873 砍树</a>。</p>
<blockquote>
<p>给定森林中每棵树的高度，伐木工将砍伐所有的树比 $H$ 高的部分，要求锯下的木材的总长至少为 $M$，并且尽量小，求 $H$。</p>
</blockquote>
<p>直接计算一个值可能不太容易，但我们可以较容易的判断某个值是否符合条件。</p>
<p>同时，答案是单调的，换句话说，随着 $H$ 降低，锯下的木材只会增加。</p>
<p>我们可以设计函数 $f(H)$，令其值为锯下木材的总长。于是我们可以对答案二分，每次检验其可行性，找到可行中最大的 $H$。</p>
<h2 id="例题-1"><a class="header" href="#例题-1">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1024">P1024 一元三次方程求解</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 砍树</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贪心-1"><a class="header" href="#贪心-1">贪心</a></h1>
<p>在算法思想一节中，我们已经介绍过贪心的思想了，这里我们谈谈应用。</p>
<h2 id="p4995-跳跳"><a class="header" href="#p4995-跳跳">P4995 跳跳！</a></h2>
<blockquote>
<p>给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$，求最耗体力的路径。</p>
</blockquote>
<p>凭借一些数学的灵感，可以猜到是在剩余的石头中，高度差当前最大的来回跳。即“大小大小”这样反复横跳。</p>
<p>如何证明呢？假设 $h_i$ 已经是要跳的序列。展开求和式</p>
<p>$$
S = \sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \sum_{k=1}^nh_k^2 - 2\sum_{k=1}^{n-1}h_kh_{k+1}
$$</p>
<p>注意到平方和为一个定值，重点在后半式。记 $H_{k} = h_{k+1}$，有</p>
<p>$$
\sum_{k=1}^{n-1}h_kH_k
$$</p>
<p>利用高中时学的排序不等式，有</p>
<p>$$
{\text 反序和} \leqslant {\text 乱序和} \leqslant {\text 顺序和}
$$</p>
<p>直接有反序最小。</p>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4995">P4995 跳跳！</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1803">P1803 凌乱的yyy / 线段覆盖</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5019">P5019 铺设道路</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="排序"><a class="header" href="#排序">排序</a></h1>
<p>假定冒泡排序是熟知。</p>
<h2 id="快速排序"><a class="header" href="#快速排序">快速排序</a></h2>
<p>快速排序的均摊复杂度是 $O(n\log n)$，最坏复杂度是 $O(n^2)$，通常快一点。</p>
<p>它的核心思想是分治。</p>
<ol>
<li>
<p>取出一个元素，这里我选的是中间的，也可以选开头，无所谓的。</p>
</li>
<li>
<p>把比这个元素小的换到左边，比这个元素大的换到右边，最后把刚才选中的元素放回去。</p>
</li>
<li>
<p>再对左右两个区间同样进行操作。</p>
</li>
</ol>
<p>正确性可能不是那么显然。</p>
<p>注意到第 2 步结束时，对于选中的元素来说，左边一定是比它小的，右边一定是比它大的。排序后左边的元素一定不会溜到右边去，右边也不会来左边。这种看起来没什么用的有序性，足以完成全部的排序。</p>
<pre><code class="language-cpp">int nn[MAXN];

void quick_sort(int l, int r) {
    if(l &gt;= r)
        return;
    int i = l, j = r;
    int x = nn[(l+r)/2];
    while(i &lt;= j) {
        while(nn[j] &gt; x)
            j--;
        while(nn[i] &lt; x)
            i++;
        if(i &lt;= j) {
            swap(nn[i], nn[j]);
            i++;
            j--;
        }
    }
    quick_sort(l, j);
    quick_sort(i, r);
}
</code></pre>
<p>更多的排序方法，例如希尔排序、归并排序、桶排序、堆排序等，这里就不讲了，一般快排够用了。想了解的可以去 <a href="https://oi-wiki.org/basic/sort-intro/">排序 - OI Wiki</a> 看看。</p>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<p>检查数列相等元素：排序后，判断相邻元素是否相等。</p>
<p>二分查找：预处理后有序的，查找会快很多，</p>
<p>快排可以做到 $O(n)$ 求第 $k$ 小数。</p>
<h2 id="例题-2"><a class="header" href="#例题-2">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5143">P5143 攀爬者</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1223">P1223 排队接水</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1177">P1177 快速排序</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1923">P1923 求第 k 小的数 </a></li>
<li><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a>（提示：两重循环会超时哦）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="递推初步"><a class="header" href="#递推初步">递推初步</a></h1>
<p>递推求数列应该都很熟悉，这里讲的简略一点。</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>还是拿 Fibonacci 数列举例，递推公式为</p>
<p>$$
F_{n+2} = F_{n+1} + F_{n}
$$</p>
<p>我们可以直接从第 $1$ 项开始推到第 $n$ 项</p>
<pre><code class="language-cpp">int f[MAXN];
f[1] = f[2] = 1;
for (int i = 3; i &lt; n; i++) {
    f[i] = f[i - 1] + f[i - 2];
}
</code></pre>
<p>类似的，只要我们能求出递推公式，那么用循环遍历求值即可。</p>
<h2 id="快速倍增法"><a class="header" href="#快速倍增法">快速倍增法</a></h2>
<p>在快速幂一节中，我们讲了如何利用矩阵加速做到 $O(\log n)$ 求第 $n$ 项。实际上我们还有一种快速倍增法。</p>
<p>$$
\begin{aligned}
F_{2k} &amp;= F_k (2F_{k+1} - F_k)\\
F_{2k+1} &amp;= F_{k+1}^2+F_k^2
\end{aligned}
$$</p>
<p>于是我们可以用这样的方法快速计算相邻两个相邻的 Fibonacci 数，复杂度与矩阵快速幂一样，但是运算量稍小一点。</p>
<h2 id="例题-3"><a class="header" href="#例题-3">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1028">P1028 数的计算</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1192">P1192 台阶问题</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1595">P1595 信封问题</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1962">P1962 斐波那契数列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态规划"><a class="header" href="#动态规划">动态规划</a></h1>
<p>动态规划的“状态”和“转移”等概念可能较为抽象，也过于灵活，我列出了较多的例题帮助思考。</p>
<p>动态规划的难点在于状态设计和子结构的挖掘。</p>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<p>对于递推，我们可以做进一步抽象。</p>
<p>还是 Fibonacci 数列，我们把 $F_i$ 称为一个状态。这个状态由 $F_{i-1}$ 和 $F_{i-2}$ 转移：</p>
<p>$$
F_{i} = F_{i-1} + F_{i-2}
$$</p>
<p>此公式称为动态转移方程，它描述了状态之间的关系。最后是边界 $F_1=F_2=1$。</p>
<p>很简单吧？来点基础模型。</p>
<h2 id="矩阵取数"><a class="header" href="#矩阵取数">矩阵取数</a></h2>
<blockquote>
<p>给定一个 $m \times n$ 的矩阵 $A$（数字三角形也差不多），从左上角开始，只能向下或向右走，求路过所有数字之和最大值。</p>
</blockquote>
<p>可以先思考一下，这道题怎么设状态比较好。</p>
<p>定义状态 $F(i,j)$ 为停在位置 $(i,j)$ 的所有路径中，路过数字之和的最大值。</p>
<p>而且由题知，一个位置只可能被从上面和左面过来。于是我们可以得到状态转移方程</p>
<p>$$
F(i,j) = A(i,j) + \max\{F(i-1,j), F(i,j-1)\}
$$</p>
<p>即两者取大。边界是显然的 $0$。</p>
<p>状态 $F(i,j)$ 具有最优子结构性，即它是走到 $(i,j)$ 下的最优解，后续的解建立在前一个子结构上，自然也是最优解。</p>
<h2 id="01-背包"><a class="header" href="#01-背包">01 背包</a></h2>
<blockquote>
<p>给定 $n$ 个物品，第 $i$ 个物品的体积为 $V_i$，价值为 $W_i$。有一容积为 $M$ 的背包，求背包内能放下的最大价值。</p>
</blockquote>
<p>设状态 $F(i,j)$ 是从前 $i$ 个物品中选出了总体积为 $j$ 的物品放入背包后，放下的最大价值。</p>
<ul>
<li>若不选第 $i$ 个物品，则 $F(i,j) = F(i-1,j)$。</li>
<li>若选第 $i$ 个物品且 $j \geqslant i$，则 $F(i,j) = F(i-1,j-V_i) + W_i$。</li>
</ul>
<p>于是转移方程为两者取 $\max$。边界自然为 $0$。</p>
<pre><code class="language-cpp">f[0][0] = 0;
for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt;= m; j++)
        f[i][j] = f[i - 1][j];
    for (int j = v[i]; j &lt;= m; j++)
        f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
}
</code></pre>
<h3 id="滚动数组"><a class="header" href="#滚动数组">滚动数组</a></h3>
<p>注意到阶段 $i$ 只和上一阶段 $i-1$ 有关。于是我们可以让数组滚动起来，重复利用，减掉一维。</p>
<p>然而在第 $i$ 阶段内 $j$ 的情况较复杂。$F(i,j)$ 依赖于 $F(i,j-V_i)$，即依赖 $j$ 是向前的，顺着循环前面先被更新，后面依赖的数据就没了。</p>
<p>怎么办？让循环倒着来，这样后面的先更新，前面不会被影响。</p>
<pre><code class="language-cpp">f[0] = 0;
for (int i = 0; i &lt; n; i++) {
    for (int j = m; j &gt;= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
</code></pre>
<p>同样，矩阵取数也可以使用滚动数组。</p>
<h2 id="完全背包"><a class="header" href="#完全背包">完全背包</a></h2>
<blockquote>
<p>给定 $n$ 种物品，第 $i$ 种物品的体积为 $V_i$，价值为 $W_i$，每种有无限个。有一容积为 $M$ 的背包，求背包内能放下的最大价值。</p>
</blockquote>
<p>自己尝试推一下，会发现正序循环恰好是所求解。</p>
<pre><code class="language-cpp">f[0] = 0;
for (int i = 0; i &lt; n; i++) {
    for (int j = v[i]; j &lt;= v[i]; j++) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
</code></pre>
<h2 id="最长公共子序列"><a class="header" href="#最长公共子序列">最长公共子序列</a></h2>
<h2 id="最长不下降子序列"><a class="header" href="#最长不下降子序列">最长不下降子序列</a></h2>
<h2 id="约瑟夫问题"><a class="header" href="#约瑟夫问题">约瑟夫问题</a></h2>
<h2 id="扩展--区间-dp"><a class="header" href="#扩展--区间-dp">扩展 · 区间 DP</a></h2>
<h2 id="扩展--数位-dp"><a class="header" href="#扩展--数位-dp">扩展 · 数位 DP</a></h2>
<h2 id="例题-4"><a class="header" href="#例题-4">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1176">P1176 路径计数2</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5146">P5146 最大差值</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1387">P1387 最大正方形</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1057">P1057 传球游戏</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1359">P1359 租用游艇</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1020">P1020 导弹拦截</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1434">P1434 滑雪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前缀和--差分"><a class="header" href="#前缀和--差分">前缀和 &amp; 差分</a></h1>
<p>前缀和是预处理思想的一个应用，提前计算好数组的和，需要时直接使用，加快速度。</p>
<p>勉强算是“数据结构”吧。</p>
<h2 id="p5638-光骓者的荣耀"><a class="header" href="#p5638-光骓者的荣耀">P5638 光骓者的荣耀</a></h2>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5638">P5638 光骓者的荣耀</a></p>
<p>题目大意：可跳过连续的 $k$ 项，求经过边的和的最小值。</p>
<p>肯定是正着跳，暴力也是显然的，对结果取 $\max$。复杂度为 $O(n^2)$。</p>
<pre><code class="language-cpp">int aa[MAXN], n;
int ans = 0x3f3f3f3f;
for (int i = 0; i &lt; n - 1; i++) {
    int sum = 0;
    for (int j = 0; j &lt; i; j++) {
        sum += aa[j];
    }
    for (int j = i + k; j &lt; n - 1; j++) {
        sum += aa[j];
    }
    ans = min(ans, sum);
}
return ans;
</code></pre>
<h2 id="优化-1-1"><a class="header" href="#优化-1-1">优化 1</a></h2>
<p>很显然超时的原因是我们每次都做了很多重复计算，主要是在求和。</p>
<p>怎么求和更快呢？这就需要用前缀和优化了。考虑预处理数组 $a$ 的前缀和 $s_i = \displaystyle\sum_{k=1}^ia_k$</p>
<pre><code class="language-cpp">int aa[MAXN], ss[MAXN];
// init...
int sum = 0;
for (int i = 0; i &lt; n - 1; i++) {
    sum += aa[i];
    ss[i] = sum;
}
</code></pre>
<p>当我们想计算 $l$ 到 $r$ 之间数组 $a$ 的和时，可以直接使用 $s_r-s_{l-1}$，不必每一次再重新计算。</p>
<p>于是可以优化得到</p>
<pre><code class="language-cpp">
int aa[MAXN], n, ss[MAXN];
// init...
int ans = 0x3f3f3f3f;
for (int i = 0; i &lt; n - 1; i++) {
    int sum = ss[i - 1] + s[n - 2] - s[i + k -1];
    ans = min(ans, sum);
}
</code></pre>
<p>仔细观察，你就会发现数组 $a$ 并没有什么保存的价值，可以删去，优化内存。</p>
<h2 id="优化-2-1"><a class="header" href="#优化-2-1">优化 2</a></h2>
<p>可能有同学想到了另一种解法，这里也讲一下。</p>
<p>注意到，答案可以看成两段和相加，也可以看作全部的和减去 $k$ 个，而全部的和是固定的。</p>
<p>我们可以采用一种队列的方式，维护从 $l$ 开始到 $r$ 结束的连续一段数字的和 $s$。当求和段向右移动时，只需 $s' = s - a_l + a_{r+1}$。</p>
<pre><code class="language-cpp">// init...
int tsum = 0;
for (int i = 0; i &lt; k; i++)
    tsum += aa[i];
int ans = tsum;
for (int i = k; i &lt; n - 1; i++) {
    tsum = tsum + aa[i] - aa[i - k];
    ans = max(ans, t);
}
return sum - ans;
</code></pre>
<h2 id="差分"><a class="header" href="#差分">差分</a></h2>
<p>类似的，有前缀和，就有差分。差分数组的前缀和是原数组。</p>
<p>差分有什么用呢？</p>
<p>差分可以把“区间增加”变成“单点增加”。详细见 <a href="https://www.luogu.com.cn/problem/P2367">P2367 语文成绩</a>。</p>
<h2 id="例题-5"><a class="header" href="#例题-5">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5638">P5638 光骓者的荣耀</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2367">P2367 语文成绩</a></li>
</ul>
<h2 id="扩展--二维前缀和"><a class="header" href="#扩展--二维前缀和">扩展 · 二维前缀和</a></h2>
<h2 id="扩展--高维前缀和"><a class="header" href="#扩展--高维前缀和">扩展 · 高维前缀和</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<p>假如我们想要得到 $3^{100} \bmod 10007$，你会怎么做？</p>
<p>你可能会写出这样的代码</p>
<pre><code class="language-cpp">const int mod = 10007;
int ans = 1;
for (int i = 0; i &lt; 100; i++)
    ans = ans * 3 % mod;
return ans;
</code></pre>
<p>假如要计算的是 $a^n \bmod p$，那么这种写法的时间复杂度是 $O(n)$。尽管 $O(n)$ 听起来已经很不错，但是，我们可以做到更快。</p>
<h2 id="平方法"><a class="header" href="#平方法">平方法</a></h2>
<p>假设初始为 $a$，自乘后得到 $a^2$，再对结果自乘得到 $a^4$，反复下去，我们可以得到一列数</p>
<p>$$
a \to a^2 \to a^{4} \to a^{8} \to a^{16} \to a^{32} \to a^{64} \to \cdots
$$</p>
<p>容易发现，它的指数的增长速度是 $2^k$，比线性增长的速度快的多。</p>
<p>我们可以尝试利用“平方法”加速幂的运算。</p>
<h2 id="递归方法"><a class="header" href="#递归方法">递归方法</a></h2>
<p>很自然的想到</p>
<p>$$
a^n = \begin{cases}
a^{n-1} \times a, &amp;n \bmod 2 = 1\\
a^{\frac{n}{2}} \times a^{\frac{n}{2}}, &amp;n \bmod 2 = 0
\end{cases}
$$</p>
<p>可以据此实现代码</p>
<pre><code class="language-cpp">const int mod = 10007;
int qpow(int a, int n) {
    if(n == 0) {
        return 1;
    } else if(n % 2 == 1) {
        return qpow(a, n - 1) * a % mod;
    } else {
        int t = qpow(a, n / 2);
        return t * t % mod;
    }
}
</code></pre>
<div id="admonition-思考" class="admonition info">
<div class="admonition-title">
<p>思考</p>
<p><a class="admonition-anchor-link" href="basic/quick-pow.html#admonition-思考"></a></p>
</div>
<div>
<p>为什么不写 <code>qpow(a, n / 2) * qpow(a, n / 2)</code>，而用 <code>t</code> 进行存储？</p>
</div>
</div>
<p>递归本身也具有一定的开销，我们可以稍加思考，改进得到非递归法。</p>
<h2 id="非递归法"><a class="header" href="#非递归法">非递归法</a></h2>
<p>还是讨论 $a^{100}$，我们可以把它拆分成“平方法”数列中的项的乘积</p>
<p>$$
a^{100} = a^{64} \times a^{32} \times a^4
$$</p>
<p>那么对于任意的 $n$，如何拆分 $a^n$ 才可以利用平方法加速呢？</p>
<p>注意到平方法数列中的指数都是 $2$ 的幂，即把 $n$ 分解为 $2$ 的幂的和，于是很自然的想到 $n$ 的二进制表示。</p>
<p>因为 $100_{10} = 1100100_2$，于是有</p>
<p>$$
\begin{matrix} 
&amp; a^1 &amp; a^2 &amp; a^4 &amp; a^8 &amp; a^{16} &amp; a^{32} &amp; a^{64} \\
100 &amp; &amp; &amp; 4 &amp; &amp; &amp; 32 &amp; 64\\
100 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 
\end{matrix}
$$</p>
<p>即二进制下该位为 $1$，则计算该位的贡献；若该位为 $0$，则不计算该位的贡献。</p>
<p>于是可以写出代码</p>
<pre><code class="language-cpp">const int mod = 10007;
int qpow(int a, int n) {
    int ans = 1;
    while(n &gt; 0) {
        if(n % 2 == 1)
            ans = ans * a % mod;
        a = a * a % mod;
        n = n / 2;
    }
    return ans;
}
</code></pre>
<p>在实际使用时往往写成这样</p>
<pre><code class="language-cpp">ll qpow(ll a, ll b, ll p) {
    ll ret = p != 1;
    for(; b; b &gt;&gt;= 1) {
        if(b &amp; 1)
            ret = a * ret % p;
        a = a * a % p;
    }
    return ret;
}
</code></pre>
<h2 id="应用-2"><a class="header" href="#应用-2">应用</a></h2>
<p>快速幂只是一个小技巧，但是应用的范围很广泛。</p>
<h3 id="数列递推"><a class="header" href="#数列递推">数列递推</a></h3>
<p>拿我们熟悉的 Fibonacci 数列举例</p>
<p>$$
F_{n+2} = F_{n+1} + F_{n}
$$ </p>
<p>可以写成矩阵乘法形式</p>
<p>$$
\left(\begin{matrix}F_{n+1}\\F_{n+2}\end{matrix}\right)
= \left(\begin{matrix}0 &amp; 1\\1 &amp; 1\end{matrix}\right)
\left(\begin{matrix}F_{n}\\F_{n+1}\end{matrix}\right)
$$</p>
<p>设 $P = \left(\begin{matrix}0 &amp; 1\\1 &amp; 1\end{matrix}\right)$ ，于是有</p>
<p>$$
\left(\begin{matrix}F_{n+1}\\F_{n+2}\end{matrix}\right)
= P^n\left(\begin{matrix}F_{1}\\F_{2}\end{matrix}\right)
$$</p>
<p>可以对矩阵使用快速幂，那么计算第 $n$ 项只需 $O(\log n)$。</p>
<h2 id="例题-6"><a class="header" href="#例题-6">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1962">P1962 斐波那契数列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结语"><a class="header" href="#结语">结语</a></h1>
<p>基础算法的学习至此告一段落。</p>
<p>接下来可以挑选感兴趣的部分学习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<p>在算法竞赛中，题目常常用到初等数论、概率与期望、多项式等很多领域的知识，是很重要的一块内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="筛法"><a class="header" href="#筛法">筛法</a></h1>
<p>我们有时需要预处理一些质数。对每一个数都进行素性测试太慢了，筛法是更好的选择。</p>
<p>以下讨论时不再强调 $1$ 的反常。</p>
<h2 id="eratosthenes-筛法"><a class="header" href="#eratosthenes-筛法">Eratosthenes 筛法</a></h2>
<p>考虑数 $x$，不管 $x$ 是否是质数，$x$ 的倍数都是合数，我们可以把 $x$ 的倍数全在表中标记划去。</p>
<p>从 $2$ 开始，把每一个遇到的数的倍数都从表中划去，则接下来第一个没被划到的数必为质数。再划去该数的倍数，找到下一个没被划到的质数……</p>
<pre><code class="language-cpp">vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes;
void Eratosthenes(int n) {
    not_p.resize(n + 1);
    for (int i = 2; i &lt;= n; i++) {
        if (!not_p[i]) {
            primes.push_back(i);
            for (int j = i; j &lt; n / i; j++)
                not_p[i * j] = true;
        }
    }
}
</code></pre>
<p>记 $x$ 的最小的非 $1$ 因子为 $\operatorname{lpf}(x)$，显然也是质因子。</p>
<p>容易发现，若 $x \notin \mathbb{P}$，则有 $\operatorname{lpf}(x) \leqslant \sqrt{x}$，即我们只需要筛到 $\sqrt{n}$ 就行；也可以把 $2$ 单独提出。</p>
<p>以上操作不改变复杂度，都是 $O(n \log \log n)$，但会显著改变常数。</p>
<h2 id="euler-筛法"><a class="header" href="#euler-筛法">Euler 筛法</a></h2>
<p>注意到，我们每一个合数都重复标记了几次，需要优化。</p>
<p>从小到大枚举 $p \in \mathbb{P}$，到 $i$ 整除 $p$ 时停止，这说明 $p$ 始终是 $i \cdot p$ 最小的因子。</p>
<p>因此对于每个合数，一定且仅会因为最小因子筛掉。因此复杂度 $O(n)$，故此筛法也称为线性筛。</p>
<pre><code class="language-cpp">vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes;
void Euler(int n) {
    not_p.resize(n + 1);
    for (int i = 2; i &lt;= n; i++) {
        if (!not_p[i])
            primes.push_back(i);
        for (auto pj : primes) {
            if (pj &gt; n / i)
                break;
            not_p[i * pj] = true;
            if (i % pj == 0)
                break;
        }
    }
}
</code></pre>
<h2 id="euler-筛预处理积性函数"><a class="header" href="#euler-筛预处理积性函数">Euler 筛预处理积性函数</a></h2>
<p>用 Euler 筛预处理积性函数 $f(x)$，需要函数满足一定的性质。常见的积性函数有 Euler $\varphi(n)$ 函数和 Mobius $\mu(n)$ 函数。</p>
<p>筛法过程中中，我们可以得到一个数的最小质因子 $p$，并且知道该数是否具有多个因子 $p$ 。</p>
<p>假设数 $i \cdot p$ 仅具有一个因子 $p$ ，由积性函数定义知</p>
<p>$$
f(i \cdot p) = f(i) f(p)
$$</p>
<p>当数 $i \cdot p$ 具有多个因子 $p$ 时，仅仅积性函数的性质是不够的，需要此时 $f(x)$ 能够容易的计算。例如</p>
<p>$$
\varphi(i \cdot p^k) = \varphi(i \cdot p^{k-1}) \cdot p, \qquad \mu(i \cdot p^k) = 0
$$</p>
<p>并且要求 $f(p)$ 也要容易计算，有代码</p>
<pre><code class="language-cpp">vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes, phi, mu;
void Euler(int n) {
    not_p.resize(n + 1);
    phi.resize(n + 1);
    mu.resize(n + 1);
    mu[1] = phi[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
        if (!not_p[i]) {
            primes.push_back(i);
            phi[i] = i - 1, mu[i] = -1;
        }
        for (auto pj : primes) {
            if (pj &gt; n / i)
                break;
            not_p[i * pj] = true;
            if (i % pj == 0) {
                phi[i * pj] = phi[i] * pj;
                mu[i * pj] = 0;
                break;
            }
            phi[i * pj] = phi[i] * (pj - 1);
            mu[i * pj] = -mu[i];
        }
    }
}
</code></pre>
<h2 id="例题-7"><a class="header" href="#例题-7">例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2568">P2568 GCD</a>，本题有 $\phi(x)$ 和 $\mu(x)$ 两种做法，详见 <a href="https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/">题解</a>，需要一定数学推导。</li>
</ul>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://oi-wiki.org/math/number-theory/sieve/">筛法 - OI Wiki</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理-crt"><a class="header" href="#中国剩余定理-crt">中国剩余定理 CRT</a></h1>
<p>若在序列 $\{n_i\}$ 中任意两个互质，求方程组</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {n_1} \\
x \equiv a_2 &amp;\pmod {n_2} \\
&amp;\vdots \\
x \equiv a_k &amp;\pmod {n_k}
\end{cases}
$$</p>
<p>的解。注意到，对于第 $i$ 个方程，我们可以构造数</p>
<p>$$
m_i = \frac{1}{n_i}\prod_{j=1}^k n_j
$$</p>
<p>再求 $m_i$ 对 $n_i$ 逆元，则此式具有性质</p>
<p>$$
(m_im_i^{-1}) \bmod n_j = \begin{cases}
1,&amp;j = i\\
0,&amp;j \ne i
\end{cases}
$$</p>
<p>这说明每一个解都不影响其他方程，可以独立求解再求和。因此有</p>
<p>$$
a_im_im_i^{-1} \equiv a_i\pmod {n_i}
$$</p>
<p>对所有的解累加求和得到方程组的解</p>
<p>$$
x \equiv \sum_{i=1}^k a_im_im_i^{-1} \pmod {\prod_{j=1}^k n_j}
$$</p>
<pre><code class="language-cpp">ll crt(const vector&lt;ll&gt; &amp;aa, const vector&lt;ll&gt; &amp;nn) {
    ll prod = 1, ret = 0, n = aa.size();
    for (auto ni : nn)
        prod *= ni;
    for (int i = 0; i &lt; n; i++) {
        ll m = prod / nn[i];
        ret += aa[i] * m * inv(m, nn[i]);
        ret %= prod;
    }
    return ret;
}
</code></pre>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 【模板】中国剩余定理(CRT)/曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础博弈"><a class="header" href="#基础博弈">基础博弈</a></h1>
<p>下面都是石子游戏，轮流取走物品。</p>
<p>方便起见，称场上 $n$ 堆石子 $a_1,\cdots,a_n$ 为局势。</p>
<p>常见的是公平组合游戏：</p>
<ul>
<li>两个玩家轮流决策，均知道游戏的完整信息。</li>
<li>以玩家无法行动作为结束标志。</li>
<li>游戏一定在有限步结束，且一定能分出胜负。</li>
</ul>
<h2 id="博弈图和状态"><a class="header" href="#博弈图和状态">博弈图和状态</a></h2>
<p>若能将当前局势看作节点，双方的操作看作节点之间的有向边，则博弈可以看作一个图论问题。</p>
<p>若先手必胜，则称该局势为必胜状态；若先手必败，则称该局势为必败状态。</p>
<p>容易验证以下关键结论：</p>
<ul>
<li>定理 1：一个局势必胜当且仅当存在至少一个后继状态必败。</li>
<li>定理 2：一个局势必败当且仅当它的所有后继状态必胜。</li>
</ul>
<h2 id="nim-博弈"><a class="header" href="#nim-博弈">Nim 博弈</a></h2>
<p>共 $n$ 堆分别有 $a_i$ 个物品，两人轮流取走任意一堆的任意个物品，不能不取。最后取光者获胜。</p>
<h3 id="原理-2"><a class="header" href="#原理-2">原理</a></h3>
<p>对于特殊情况</p>
<p>$$
a_1 \oplus \cdots \oplus a_n = 0
$$</p>
<p>若先手取走了 $k$，则后手应尝试也取 $k$，保持异或和为 $0$，因此后手总是可以行动，永远不败。</p>
<p>考虑证明后手总是能取 $k$。由异或定义知，一定存在 $a_i$ 在 $k$ 的 ${\rm high\_bit}(k)$ 下是 $1$，否则 $a_i$ 该位不可能为 $1$。</p>
<p>将此 $a_i$ 变成 $a_i' = a_i \oplus k$，则该位由 $1$ 变 $0$，即有 $a_i &gt; a_i \oplus k$。于是应在 $a_i$ 取 $a_i - a_i \oplus k$。</p>
<p>对于</p>
<p>$$
a_1 \oplus \cdots \oplus a_n = k \ne 0
$$</p>
<p>由前论述，先手一定存在取走 $k$ 的取法，转为后手永远不败。</p>
<pre><code class="language-cpp">bool Nim(const vector&lt;ll&gt; &amp;a, ll n) {
    ll ans = 0;
    for (auto ai : a)
        ans ^= ai;
    if (ans == 0)
        return true;
    return false;
}
</code></pre>
<h2 id="wythoff-博奕"><a class="header" href="#wythoff-博奕">Wythoff 博奕</a></h2>
<p>两堆分别有 $a,b$ 各物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，不可不取。最后取光者获胜。</p>
<h3 id="原理-3"><a class="header" href="#原理-3">原理</a></h3>
<p>先手必输的局势称为奇异局势（Cold Position）。</p>
<p>奇异局势可以简单的判断</p>
<pre><code class="language-cpp">const ld phi = 1.6180339887498948482045868343656;
bool Wythoff(ll a, ll b) {
    if (a &gt; b)
        swap(a, b);
    ll t = (ll) (b - a) * phi;
    if (t == a)
        return false;
    return true;
}
</code></pre>
<p>所有自然数都出现在奇异局势中，不重不漏。第 $k$ 个奇异局势（其中 $(0,0)$ 为第 $0$ 个）为</p>
<p>$$
(a_{k-1},b_{k-1}) = (\lfloor \varphi k\rfloor , \lfloor \varphi k \rfloor + k)
$$</p>
<p>其中 $\varphi = \dfrac{\sqrt{5}+1}{2}$ 为黄金分割数。</p>
<h2 id="sg-函数"><a class="header" href="#sg-函数">SG 函数</a></h2>
<p>Todo</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dirichlet-卷积"><a class="header" href="#dirichlet-卷积">Dirichlet 卷积</a></h1>
<p>对于数论函数 $f(x)$ 和 $g(x)$，则定义</p>
<p>$$
(f \ast g)(x) = \sum_{d \mid x} f(d) g\left(\frac{x}{d}\right) = \sum_{ab=x}f(a)g(b)
$$</p>
<h2 id="性质"><a class="header" href="#性质">性质</a></h2>
<p>Dirichlet 卷积除了满足卷积的几个性质，还有额外的性质。</p>
<p>卷积存在单位函数 $\varepsilon(n) = [n = 1]$。</p>
<p>卷积存在逆元 $f^{-1}$，其中 $f^{-1}(1) = 0$，当 $n &gt; 1$ 时有</p>
<p>$$
g(n) = - \frac{1}{f(1)} \sum_{d \mid n, d &lt; n} f\left(\frac{n}{d}\right) g(d)
$$</p>
<h2 id="常见公式"><a class="header" href="#常见公式">常见公式</a></h2>
<p>常见的公式有</p>
<p>$$
\begin{matrix}
\mu \ast 1 = \varepsilon &amp; 1 \ast 1 = d &amp; {\rm Id}_k \ast 1 = \sigma_k \\
{\varphi} \ast 1 = {\rm Id} &amp; \lambda \ast 1 = 1_{\rm Sq} &amp; d^3 \ast 1 = (d \ast 1)^2
\end{matrix}
$$</p>
<h2 id="mobius-反演"><a class="header" href="#mobius-反演">Mobius 反演</a></h2>
<p>利用 $\mu \ast 1 = \varepsilon$，展开有</p>
<p>$$
\sum_{d \mid n} \mu(d) = \varepsilon(n) = [n = 1]
$$</p>
<p>进一步，对于数论函数 $f(n), g(n)$，有</p>
<p>$$
\begin{aligned}
f(n) = \sum_{d \mid n}g(d) \Rightarrow g(n) = \sum_{d \mid n} \mu (d) f\left(\frac{n}{d}\right) \\
f(n) = \sum_{n \mid d}g(d) \Rightarrow g(n) = \sum_{n \mid d} \mu \left(\frac{n}{d}\right) f(d) \\
\end{aligned}
$$</p>
<h2 id="杜教筛"><a class="header" href="#杜教筛">杜教筛</a></h2>
<p>对于数论函数 $f(n)$ 和它的和函数 $S(n) = \sum f(n)$，再给数论函数 $g(n)$ 的卷积求和有</p>
<p>$$
\begin{aligned}
\sum_{i=1}^n (f \ast g)(n) &amp;= \sum_{i=1}^n \sum_{d=1}^i g(d) f\left(\frac{i}{d}\right)[d \mid i]\\
&amp;= \sum_{d=1}^n \sum_{i=d}^n g(d) f\left(\frac{i}{d}\right)[d \mid i]\\
&amp;= \sum_{d=1}^n g(d) \sum_{i=1}^{\lfloor n/d \rfloor} f(i)
\end{aligned}
$$</p>
<p>从中摘出第一项，有</p>
<p>$$
g(1)S(n) = \sum_{i=1}^n (f \ast g)(i) - \sum_{i=2}^n g(i) S\left(
\left\lfloor \frac{n}{i} \right\rfloor \right)
$$</p>
<p>若前者可以快速计算，后者可以数论分块，就可以在较快的时间求得 $S(n)$。复杂度 $O(n^{\frac{3}{4}})$。</p>
<h2 id="dirichlet-级数"><a class="header" href="#dirichlet-级数">Dirichlet 级数</a></h2>
<p>知道这个级数并没有什么用。。。</p>
<p>首先来看 Riemann $\zeta(s)$ 函数</p>
<p>$$
\zeta(s) = \sum_{n=1}^\infty\frac{1}{n^s} = \frac{1}{1^s} + \frac{1}{2^s} + \cdots, \operatorname{Re}(s) &gt; 1
$$</p>
<p>类似的，我们定义 Dirichlet 生成函数</p>
<p>$$
DG(f;s) = \sum_{n=1}^\infty \frac{f(n)}{n^s}, \operatorname{Re}(s) &gt; 1
$$</p>
<p>于是乘积有</p>
<p>$$
\begin{aligned}
DG(f;s)DG(g;s) &amp;= \left( \sum_{n=1}^\infty \frac{f(n)}{n^s} \right) \left( \sum_{n=1}^\infty \frac{g(n)}{n^s} \right)\\
&amp;= \sum_{n=1}^\infty \left( \sum_{ab=n} \frac{f(a)}{a^s} \frac{g(b)}{b^s} \right)\\
&amp;= \sum_{n=1}^\infty \left( \sum_{ab=n} \frac{(f \ast g)(n)}{n^s} \right)\\
&amp;= DG(f \ast g;s)
\end{aligned}
$$</p>
<p>常见的有</p>
<p>$$
\begin{aligned}
DG(\mu;s) &amp;= \sum_{n=1}^\infty \frac{\mu(n)}{n^s} = \frac{1}{\zeta(s)} \\
DG(\varphi;s) &amp;= \sum_{n=1}^\infty \frac{\varphi(n)}{n^s} = \frac{\zeta(s-1)}{\zeta(s)}
\end{aligned}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式简介"><a class="header" href="#多项式简介">多项式简介</a></h1>
<p>我们讨论多项式时，基本是在模质数意义下的，最常见的是 $\mathbb{F}_{998244353}$。</p>
<p>一元多项式可以形象的理解为一个数组</p>
<p>$$
f(x) = \sum_{i=0}^n f_i x^i = f_0 + f_1 x + f_2 x^2 + \cdots + f_n x^n
$$</p>
<p>它的“长度” $\operatorname{deg}(f) = n$，记为多项式的度数。其中含 $x^j$ 项对应的系数表示为 $[x^j]f$，或者在不引起冲突的情况下记作 $f_j$。</p>
<p>形式幂级数则拥有无限的长度</p>
<p>$$
g(x) = \sum_{i=0}^{\infty} g_i x^i = g_0 + g_1x + g_2x^2 +  \cdots
$$</p>
<p>多项式可以看作其截取 $f = g \bmod x^{n+1}$。</p>
<p>我们经常在计算机中通过 <code>vector&lt;int&gt;</code> 或者数组表示。</p>
<pre><code class="language-cpp">constexpr int P = 998244353;

int mo(int u) {
    return u &gt;= P ? u - P : u;
}

struct Poly : public vector&lt;int&gt; {
#define T (*this)
    using vector::vector;
    int deg() {
        return size();
    }
    Poly &amp;redeg(int m) {
        return resize(m), T;
    }
    Poly cut(int m) const {
        return {begin(), begin() + min(m, deg())};
    }
    // 其他操作。。。
#undef T
};
</code></pre>
<h2 id="加法"><a class="header" href="#加法">加法</a></h2>
<p>对于形式幂级数 $f$ 和 $g$，我们定义其加法</p>
<p>$$
(f \pm g)(x) = \sum_{i=0}^{\infty} (f_i \pm g_i) x^i
$$</p>
<pre><code class="language-cpp">friend Poly operator+(const Poly &amp;f, const Poly &amp;g) {
    int m = max(f.deg(), g.deg());
    Poly h = Poly(f).redeg(m);
    for (int i = 0; i &lt; g.deg(); i++)
        h[i] = mo(h[i] + g[i]);
    return h;
}
friend Poly operator-(const Poly &amp;f, const Poly &amp;g) {
    int m = max(f.deg(), g.deg());
    Poly h = Poly(f).redeg(m);
    for (int i = 0; i &lt; g.deg(); i++)
        h[i] = mo(h[i] - g[i] + P);
    return h;
}
</code></pre>
<h2 id="乘法"><a class="header" href="#乘法">乘法</a></h2>
<p>形式幂级数的乘法也称为卷积，记作</p>
<p>$$
(f \ast g)(x) = \sum_{n=0}^{\infty} \left( \sum_{i=0}^n f_i g_{n-i} \right) x^n
$$</p>
<p>这里给出一种 $O(n^2)$ 的朴素的实现</p>
<pre><code class="language-cpp">friend Poly operator*(const Poly &amp;f, const Poly &amp;g) {
    int m = f.deg() + g.deg() - 1;
    Poly h(m);
    for (int i = 0; i &lt; f.deg(); i++) {
        for (int j = 0; j &lt; g.deg(); j++) {
            h[i + j] = (h[i + j] + 1ll * f[i] * g[j]) % P;
        }
    }
    return h;
}

Poly operator*(int k) {
    Poly f = T;
    for (auto &amp;fi : f)
        fi = 1ll * fi * k % P;
    return f;
}
</code></pre>
<p>正常的实现是 FFT/NTT，其复杂度是 $O(n \log n)$，详细请看 <a href="math/poly/fft.html">FFT</a>。</p>
<p>卷积本身也很重要，更深入的内容请看，详细请看 <a href="math/poly/convolution.html">卷积</a></p>
<h2 id="求导"><a class="header" href="#求导">求导</a></h2>
<p>形式幂级数 $f$ 的导数</p>
<p>$$
f'(x) = \sum_{i=0}^\infty (i+1) f_{i+1} x^i
$$</p>
<pre><code class="language-cpp">Poly deriv() const {
    Poly f(deg() - 1);
    for (int i = 1; i &lt; deg(); i++)
        f[i - 1] = 1ll * i * T[i] % P;
    return f;
}
</code></pre>
<h2 id="积分"><a class="header" href="#积分">积分</a></h2>
<p>形式幂级数 $f$ 的积分</p>
<p>$$
\int f(x) {\rm d} x = \sum_{i=0}^\infty \frac{f_{i-1}}{i} x^i
$$</p>
<pre><code class="language-cpp">Poly integr() const {
    Poly f(deg() + 1);
    pre_inv(deg() + 1);
    for (int i = deg(); i &gt; 0; --i)
        f[i] = 1ll * Inv[i] * T[i - 1] % P;
    return f;
}
</code></pre>
<h2 id="乘法逆"><a class="header" href="#乘法逆">乘法逆</a></h2>
<p>对于形式幂级数 $f$，如果存在 $g$ 使得</p>
<p>$$
f \ast g = 1
$$</p>
<p>那么称 $g$ 为 $f$ 的乘法逆，记作 $f^{-1}$。</p>
<p>容易证明，对于 $g_0 = g \bmod x^n$，有</p>
<p>$$
f \ast g_0 \equiv 1 \pmod{x^n}
$$</p>
<h2 id="指数"><a class="header" href="#指数">指数</a></h2>
<p>仿照分析学中指数函数的定义，我们可以定义形式幂级数的指数函数。</p>
<p>$$
\exp(f) = \sum_{i=0}^\infty \frac{f^i}{i!} = 1 + f + \frac{f^2}{2!} + \cdots
$$</p>
<p>容易验证其仍有性质</p>
<p>$$
({\rm e}^f)' = f' \ast {\rm e}^f
$$</p>
<h2 id="对数"><a class="header" href="#对数">对数</a></h2>
<p>对数函数的定义是指数的逆函数，可以得出其展开式</p>
<p>$$
\ln(1 - f) = - \sum_{i=1}^\infty \frac{f^i}{i!}
$$</p>
<p>容易验证其仍有性质</p>
<p>$$
(\ln f)' = \frac{f'}{f}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="卷积"><a class="header" href="#卷积">卷积</a></h1>
<p>我对卷积理解很浅，先抛砖引玉，如有错误还请指正。</p>
<p>我也不知道卷积是什么，常见的是连续形式</p>
<p>$$
(f \ast g)(n) = \int_{-\infty}^{\infty} f(\tau)g(n-\tau) {\rm d} \tau
$$</p>
<p>和离散形式</p>
<p>$$
(f \ast g)(n) = \sum_{\tau=-\infty}^\infty f(\tau)g(n-\tau)
$$</p>
<p>如果没有特殊强调，只讨论离散形式的卷积。</p>
<p>卷积总是满足</p>
<ol>
<li>交换律 $f \ast g = g \ast f$</li>
<li>结合律 $f \ast (g \ast h) = (f \ast g) + (f \ast h)$</li>
<li>分配律 $f \ast (g + h) = (f \ast g) + (f \ast h)$</li>
<li>数乘结合律 $\mu (f \ast g) = (\mu f) \ast g = f \ast (\mu g)$</li>
<li>微分（差分）定理 ${\rm D} (f \ast g) = {\rm D}f \ast g = f \ast {\rm D}g$</li>
</ol>
<h2 id="级数"><a class="header" href="#级数">级数</a></h2>
<p>级数乘法是离散卷积的一个重要例子。对于级数</p>
<p>$$
\begin{aligned}
f(x) = \sum_{i=0}^{\infty} f_ix^i &amp;=  f_0 + f_1 x + f_2x^2 + \cdots \\
g(x) = \sum_{i=0}^{\infty} g_ix^i &amp;=  g_0 + g_1 x + g_2x^2 + \cdots
\end{aligned}
$$</p>
<p>它们的乘法是 $h(x) = f(x)g(x) = \sum\limits_{k=0}^{\infty} h_kx^k$，其中</p>
<p>$$
h_k = \sum_{i+j=k}f_ig_j
$$</p>
<p>因此看到相乘下标之和可能为为定值时，要主动想到卷积。</p>
<h2 id="卷积定理"><a class="header" href="#卷积定理">卷积定理</a></h2>
<p>设 Fourier 变换为 $\mathcal{F}$，有</p>
<p>$$
\mathcal{F}(f \ast g) = \mathcal{F}(f) \cdot \mathcal{F}(g)
$$</p>
<p>该卷积定理是 FFT 的基础。</p>
<h2 id="其他卷积"><a class="header" href="#其他卷积">其他卷积</a></h2>
<p>卷积有很多形式。</p>
<h3 id="dirichlet-卷积-1"><a class="header" href="#dirichlet-卷积-1">Dirichlet 卷积</a></h3>
<p>对于数论函数 $f(x)$ 和 $g(x)$，则定义</p>
<p>$$
(f \ast g)(x) = \sum_{d \mid x} f(d) g\left(\frac{x}{d}\right) = \sum_{ab=x}f(a)g(b)
$$</p>
<p>在 Mobius 反演中有重要应用。详见 <a href="math/poly/../dirichlet/">Dirichlet 卷积</a>。</p>
<h2 id="快速加法"><a class="header" href="#快速加法">快速加法</a></h2>
<p>来看题目 <a href="https://www.luogu.com.cn/problem/SP8372">SP8372 TSUM - Triple Sums</a>。给定 $n$ 个整数 $\{a_n\}$，对于所有的 $S$，求满足 $a_i+a_j+a_k=S$ 且 $i &lt; j &lt; k$ 的 $(i,j,k)$ 数量。</p>
<p>先不考虑 $i &lt; j &lt; k$，构造多项式</p>
<p>$$
F(x) = \sum_{i=1}^n x^{a_i}
$$</p>
<p>那么 $[x^S]F^3(x)$ 即是所求结果。再考虑去掉重复数，简记轮换和 $\sum\limits_{cyc}$ 为 $\sum$，容斥有</p>
<p>$$
\begin{aligned}
\left(\sum x\right)^3 &amp;= \sum  x^3 + 3 \sum  x^2y + 6 \sum xyz\\
\left(\sum x^2\right)\left(\sum x\right) &amp;= \sum x^3 + \sum  x^2y
\end{aligned}
$$</p>
<p>因此构造 $G(x) = \sum x^{2a_i}, H(x) = \sum x^{3a_i}$，又不同数的轮换共出现六次，解得</p>
<p>$$
6 A(x) = F^3(x) - 3G(x)A(x) + 2H(x)
$$</p>
<p>最终 $[x^S]A(x)$ 即是答案。</p>
<h2 id="字符串匹配"><a class="header" href="#字符串匹配">字符串匹配</a></h2>
<p>考虑用 FFT 解决字符串匹配。定义匹配函数</p>
<p>$$
d(x,y) = [x = y]
$$</p>
<p>给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义</p>
<p>$$
f(k) = \sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k})
$$</p>
<p>即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算</p>
<p>$$
d(x,y) = (x - y)^2
$$</p>
<p>再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有</p>
<p>$$
\begin{aligned}
f(k) &amp;= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\
&amp;= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k}
\end{aligned}
$$</p>
<p>前面两项能够预处理，最后一项是卷积，可以用 FFT。于是最终复杂度是 $O(n \log n)$。</p>
<h3 id="带通配符匹配"><a class="header" href="#带通配符匹配">带通配符匹配</a></h3>
<p>这个复杂度比 KMP 还高的 FFT 版字符串匹配有什么用呢？来看题目 <a href="https://www.luogu.com.cn/problem/P4173">P4173 残缺的字符串</a>。</p>
<p>仅令通配符的字符值为 $0$，再搓个匹配函数</p>
<p>$$
d(x,y) = xy(x-y)^2
$$</p>
<p>然后大力展开</p>
<p>$$
\begin{aligned}
f(k) &amp;= \sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\
&amp;= \sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2
\end{aligned}
$$</p>
<p>注意到三个都是卷积，全都可以 FFT。于是最终复杂度是 $O(n \log n)$。</p>
<h3 id="失配次数"><a class="header" href="#失配次数">失配次数</a></h3>
<p>来看题目 <a href="https://codeforces.com/problemset/problem/528/D">CF528D Fuzzy Search</a>。注意到，我们新搓的匹配函数 $d$ 由于有个平方，只保留了是否完全匹配的信息，不再能计算失配次数。</p>
<p>考虑再搓个新匹配函数。设字符集为 $W$（无通配符），枚举每个字符</p>
<p>$$
d(x,y) = [x = y] = \sum_{t \in W} [x = t][y = t]
$$</p>
<p>然后代入</p>
<p>$$
\begin{aligned}
f(k) &amp;= \sum_{i=0}^{m-1}\sum_{t \in W} [A_i = t][B_{i-m+k} = t]\\
&amp;= \sum_{t \in W} \sum_{i=0}^{m-1}[S_{m-i} = t][B_{i-m+k} = t]
\end{aligned}
$$</p>
<p>于是复杂度 $O(|W|n\log n)$。</p>
<p>再计算通配符的影响。容斥可知通配符的贡献为：字符串 $A$ 和 $B[k-m\ldots k-1]$ 中通配符的数量，减去对应位置都是通配符的数量。</p>
<p>前者可以预处理，后者即是再来一遍卷积。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft"><a class="header" href="#fft">FFT</a></h1>
<p>前置知识：复数、原根、卷积。</p>
<p>对于 $n$ 次多项式</p>
<p>$$
\begin{aligned}
f(x) = \sum_{i=0}^n f_ix^i &amp;=  f_0 + f_1 x + f_2x^2 + \cdots + g_nx^n \\
g(x) = \sum_{i=0}^n g_ix^i &amp;=  g_0 + g_1 x + g_2x^2 + \cdots + g_nx^n
\end{aligned}
$$</p>
<p>它们的乘法是 $F(x) = f(x)g(x) = \sum\limits_{k=0}^{2n} c_kx^k$，其中</p>
<p>$$
c_k = \sum_{i+j=k}f_ig_j
$$</p>
<p>因此计算多项式的乘积需要 $n^2$ 次系数乘法，我们需要优化。</p>
<h2 id="点值表示法"><a class="header" href="#点值表示法">点值表示法</a></h2>
<p>$n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。</p>
<p>考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到</p>
<p>$$
(x_k,F(x_k)) = \left(x_k, f(x_k)g(x_k)\right)
$$</p>
<p>于是求多项式的乘法，可以先从系数表示法转换为点值表示法，做完乘法再变回去。</p>
<h2 id="单位原根"><a class="header" href="#单位原根">单位原根</a></h2>
<p>称方程 $x^n = 1$ 的 $n$ 个解为单位根，其中特殊的一个记作 $\omega_n = e^{\frac{2 \pi i}{n}}$，称为单位原根。根据 Euler 公式，有</p>
<p>$$
\omega_n = e^{\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi}{n}\right) + i \sin \left(\frac{2\pi}{n}\right)
$$</p>
<p>即 $\omega_n$ 是单位圆上的一个点，全部的 $n$ 个单位根</p>
<p>$$
x_k = \omega_n^k = e^{k\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi k}{n}\right) + i \sin \left(\frac{2\pi k}{n}\right) 
$$</p>
<p>恰全是单位元的 $n$ 等分点。因此根据 Euler 公式，<strong>单位根之间的乘法就是在单位元上转圈圈。</strong></p>
<h2 id="dft"><a class="header" href="#dft">DFT</a></h2>
<p>设多项式 $f(x) = \sum\limits_{k=0}^{n-1} f_kx^k$，并记 $\omega = \omega_n$，则称向量</p>
<p>$$
\operatorname{DFT}_{\omega}(f) =( f(1), f(\omega^1), \cdots, f(\omega^{n-1}) )
$$</p>
<p>为 $f$ 的离散 Fourier 变换（DFT）。</p>
<p>DFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。</p>
<p>IDFT 存在性质</p>
<p>$$
(\operatorname{DFT}_{\omega})^{-1} = \frac{1}{n} (\operatorname{DFT}_{\omega^{-1}})
$$</p>
<p>篇幅所限，不放证明。现在我们可以统一的处理 DFT 和 IDFT。</p>
<h2 id="分治-1"><a class="header" href="#分治-1">分治</a></h2>
<p>利用单位元根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式</p>
<p>$$
\begin{aligned}
f(x) &amp;= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\
&amp;= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6)
\end{aligned}
$$</p>
<p>奇偶分别建立函数</p>
<p>$$
\begin{aligned}
f^{[0]}(x) &amp;= f_0 + f_2x + f_4x^2 + f_6x^3 \\
f^{[1]}(x) &amp;= f_1 + f_3x + f_5x^2 + f_7x^3
\end{aligned}
$$</p>
<p>则原来的函数可以表示为</p>
<p>$$
f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2)
$$</p>
<p>一般的，对于度小于 $n$ 的多项式 $f(x)$，利用单位原根的性质有</p>
<p>$$
\begin{aligned}
f(\omega_{n}^k) &amp;= f^{[0]}(\omega_{n}^k \cdot \omega_{n}^k) + \omega_{n}^kf^{[1]}(\omega_{n}^k \cdot \omega_{n}^k) \\
&amp;= f^{[0]}(\omega_{n}^{2k}) + \omega_{n}^kf^{[1]}(\omega_{n}^{2k}) \\
&amp;= f^{[0]}(\omega_{n/2}^{k}) + \omega_{n}^kf^{[1]}(\omega_{n/2}^{k})
\end{aligned}
$$</p>
<p>同理可得</p>
<p>$$
\begin{aligned}
f(\omega_{n}^{k+n/2}) &amp;= f^{[0]}(\omega_{n}^{2k+n}) + \omega_{n}^{k+n/2}f^{[1]}(\omega_{n}^{2k+n}) \\
&amp;= f^{[0]}(\omega_{n/2}^{k}) - \omega_{n}^{k}f^{[1]}(\omega_{n/2}^{k})
\end{aligned}
$$</p>
<p>因此我们需要把多项式的系数向上补到 $2^n$ 个，方便分治。</p>
<p>在 DFT 中使用有</p>
<p>$$
\begin{aligned}
\operatorname{DFT}_{\omega}(f)[j] &amp;= \operatorname{DFT}_{\omega^2}(f^{[0]})[j] + \omega^j\operatorname{DFT}_{\omega^2}(f^{[1]})[j] \\
\operatorname{DFT}_{\omega}(f)[j + n/2] &amp;= \operatorname{DFT}_{\omega^2}(f^{[0]})[j] - \omega^j\operatorname{DFT}_{\omega^2}(f^{[1]})[j]
\end{aligned}
$$</p>
<p>至此，我们可以写出递归版的 FFT。</p>
<pre><code class="language-cpp">void DFT(Comp *f, int n, int type) {
    if (n == 1)
        return;
    for (int i = 0; i &lt; n; i++)
        tmp[i] = f[i];
    for (int i = 0; i &lt; n; i++) {  // 偶数放左边，奇数放右边
        if (i &amp; 1)
            f[n / 2 + i / 2] = tmp[i];
        else
            f[i / 2] = tmp[i];
    }
    Comp *g = f, *h = f + n / 2;
    DFT(g, n / 2, type), DFT(h, n / 2, type);
    Comp step(cos(2 * PI / n), sin(2 * PI * type / n));
    Comp cur(1, 0);

    for (int k = 0; k &lt; n / 2; k++) {
        tmp[k] = g[k] + cur * h[k];
        tmp[k + n / 2] = g[k] - cur * h[k];
        cur = cur * step;
    }
    for (int i = 0; i &lt; n; i++)
        f[i] = tmp[i];
}
</code></pre>
<h2 id="蝴蝶变换"><a class="header" href="#蝴蝶变换">蝴蝶变换</a></h2>
<p>递归分治总是不尽人意的，如果能一次到位就更好了。还是以 $7$ 次多项式为例</p>
<ul>
<li>初始 $\{x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7\}$</li>
<li>一次 $\{x^0,x^2,x^4,x^6\},\{x^1,x^3,x^5,x^7\}$</li>
<li>两次 $\{x^0,x^4\},\{x^2,x^6\},\{x^1,x^5\},\{x^3,x^7\}$</li>
<li>结束 $\{x^0\},\{x^4\},\{x^2\},\{x^6\},\{x^1\},\{x^5\},\{x^3\},\{x^7\}$</li>
</ul>
<p>写出二进制的形式，可以发现规律</p>
<p>$$
\begin{matrix}
\text{初始}    &amp; 0    &amp; 1    &amp; 2    &amp; 3    &amp; 4    &amp; 5    &amp; 6    &amp; 7    &amp;\\
\text{初始(2)} &amp; 000  &amp; 001  &amp; 010  &amp; 011  &amp; 100  &amp; 101  &amp; 110  &amp; 111  &amp;\\
\text{结束(2)} &amp; 000  &amp; 100  &amp; 010  &amp; 110  &amp; 001  &amp; 101  &amp; 011  &amp; 111  &amp;\\
\text{结束}    &amp; 0    &amp; 4    &amp; 2    &amp; 6    &amp; 1    &amp; 5    &amp; 3    &amp; 7    &amp;
\end{matrix}
$$</p>
<p>结束和开始的二进制恰好是相反的。这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。</p>
<p>我们可以 $O(n)$ 的预处理出变换数组。设 <code>R(x)</code> 是 $x$ 的变换结果，则 <code>R(x&gt;&gt;1)</code> 是已求的。</p>
<p>$$
\begin{aligned}
\texttt{000abcd} &amp;\to \texttt{dcba000} \\
\texttt{00abcdx} &amp;\to \texttt{xdcba00}
\end{aligned}
$$</p>
<p>即是把 <code>R(x&gt;&gt;1)</code> 右移一位再补上最高位即可。代码如下</p>
<pre><code class="language-cpp">int lim = 1, lim_2;
while (lim &lt;= n + m)
    lim &lt;&lt;= 1;
lim_2 = lim &gt;&gt; 1;
for (int i = 0; i &lt; lim; ++i) {
    rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;
    if (i &amp; 1)
        rev[i] |= lim &gt;&gt; 1;
    // 或者合并写为
    // rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * lim_2);
}
</code></pre>
<p>现在我们可以写出非递归版的 FFT。</p>
<pre><code class="language-cpp">void FFT(Comp *f, int n, int type) {
    for (int i = 0; i &lt; n; ++i) {
        if (i &lt; rev[i]) {
            swap(f[i], f[rev[i]]);
        }
    }
    for (int h = 2; h &lt;= n; h &lt;&lt;= 1) {
        Comp step(cos(2 * PI / h), sin(2 * PI * type / h));
        for (int j = 0; j &lt; n; j += h) {
            Comp cur(1, 0);
            for (int k = j; k &lt; j + h / 2; k++) {
                Comp f1 = f[k], f2 = f[k + h / 2];
                f[k] = f1 + cur * f2;
                f[k + h / 2] = f1 - cur * f2;
                cur = cur * step;
            }
        }
    }
    if (type == 1)
        return;
    for (int i = 0; i &lt; n; i++)
        f[i].x /= n, f[i].y /= n;
}
</code></pre>
<h2 id="三步并做两步"><a class="header" href="#三步并做两步">三步并做两步</a></h2>
<p>实战一下：<a href="https://www.luogu.com.cn/problem/P3803">P3803 多项式乘法</a>。</p>
<p>我们的计算步骤是：</p>
<pre><code class="language-cpp">FFT(F, lim, 1);
FFT(G, lim, 1);
for (int i = 0; i &lt;= lim; i++)
    F[i] = F[i] * G[i];
FFT(F, lim, -1);
</code></pre>
<p>实际上，我们并不用三次 FFT，两次足以。注意到若把 $F(x)$ 放在实部而 $G(x)$ 放在虚部</p>
<p>$$
(F + iG)^2 = (F^2-G^2) + 2iFG
$$</p>
<p>平方之后虚部恰是答案。</p>
<h2 id="无-rev"><a class="header" href="#无-rev">无 REV</a></h2>
<p>实际上 REV 是可以消掉的，完全的推导比较复杂，这里只是以板子的形式给出。</p>
<pre><code class="language-cpp">template &lt;class iter&gt;
void ntt(iter f, int n) {
    pre_w(n), ntt_size += n;
    for (int l = n / 2; l; l &gt;&gt;= 1)
        for (int i = 0; i &lt; n; i += l * 2)
            for (int j = 0; j &lt; l; j++) {
                int x = f[i + j], y = f[i + j + l];
                f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
                f[i + j] = mo(x + y);
            }
}

template &lt;class iter&gt;
void intt(iter f, int n) {
    pre_w(n), ntt_size += n;
    for (int l = 1; l &lt; n; l &lt;&lt;= 1)
        for (int i = 0; i &lt; n; i += l * 2)
            for (int j = 0; j &lt; l; j++) {
                int x = f[i + j];
                int y = 1ll * w[j + l] * f[i + j + l] % P;
                f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
            }
    const int iv = qpow(n);
    for (int i = 0; i &lt; n; i++)
        f[i] = 1ll * f[i] * iv % P;
    reverse(f + 1, f + n);
}
</code></pre>
<h2 id="应用-3"><a class="header" href="#应用-3">应用</a></h2>
<p>FFT 是卷积计算的基础工具。更多应用见 <a href="math/poly/../convolution/">卷积</a>。</p>
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3803">P3803 多项式乘法</a></li>
</ul>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://oi-wiki.org/math/poly/fft/">快速傅里叶变换 - OI Wiki</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式牛顿迭代"><a class="header" href="#多项式牛顿迭代">多项式牛顿迭代</a></h1>
<blockquote>
<p>尝试不带 FFT/NTT 讲解，似乎真的能讲？</p>
</blockquote>
<p>对于给定的 $A(g) = 0$，假如我们已经求得 $g_0 = g \bmod x^n$，那么可以倍增的求出 $g_1 = g \bmod x^{2n}$。</p>
<p>对 $A(g)$ 在 $g = g_0$ 处做泰勒展开</p>
<p>$$
0 = A(g) = A(g_0) + \frac{A'(g_0)}{1!}(g - g_0) + \frac{A''(g_0)}{2!}(g - g_0)^2 + \cdots 
$$</p>
<p>注意到 $g-g_0$ 前 $n$ 项都为 $0$，那么</p>
<p>$$
0 \equiv A(g) \equiv  A(g_0) + A'(g_0)(g - g_0) \pmod {x^{2n}}
$$</p>
<p>因此</p>
<p>$$
g \equiv g_0 - \frac{A(g_0)}{A'(g_0)} \pmod{x^{2n}}
$$</p>
<p>更具体的，可以写做</p>
<p>$$
g \equiv g_0 - \frac{A(g_0)}{\frac{\partial A'}{\partial g}(g_0)} \pmod{x^{2n}}
$$</p>
<h2 id="多项式-inv"><a class="header" href="#多项式-inv">多项式 inv</a></h2>
<p>不妨设 $A(g) = f \ast g - 1 = 0$，套公式有</p>
<p>$$
\begin{aligned}
g &amp;\equiv g_0 - \frac{f \ast g_0 - 1}{f}\\
&amp;\equiv g_0 - (f \ast g_0 - 1) \ast g_0\\
&amp;\equiv 2 g_0 - f \ast g_0^2 \pmod{x^{2n}}
\end{aligned}
$$</p>
<pre><code class="language-cpp">Poly inv(int m) const {
    Poly x = {qpow(T[0])};
    for (int t = 2; t &lt; m * 2; t *= 2) {
        x = x * 2 - (x * x) * cut(t);
        x.redeg(t);
    }
    return x.redeg(m);
}

Poly div(int m, const Poly&amp; g) const {
    if (deg() == 0)
        return {};
    return (cut(m) * g.inv(m)).redeg(m);
}
</code></pre>
<h2 id="多项式-ln"><a class="header" href="#多项式-ln">多项式 ln</a></h2>
<p>依据</p>
<p>$$
\ln f = \int \frac{f'}{f}
$$</p>
<p>有</p>
<pre><code class="language-cpp">Poly ln(int m) const {
    return deriv().div(m - 1, cut(m)).integr();
}
</code></pre>
<h2 id="多项式-exp"><a class="header" href="#多项式-exp">多项式 exp</a></h2>
<p>令 $A(g) = \ln g - f = 0$，有</p>
<p>$$
\begin{aligned}
g &amp;\equiv g_0 - \frac{\ln g_0 - f}{1 / g_0}\\
&amp;\equiv g_0 \ast (1 - \ln g_0 + f) \pmod{x^{2n}}
\end{aligned}
$$</p>
<pre><code class="language-cpp">Poly exp(int m) const {
    Poly x = {1};
    for (int t = 2; t &lt; m * 2; t *= 2) {
        x = x * (Poly{1} - x.ln(t) + cut(t));
        x.redeg(t);
    }
    return x.redeg(m);
}
</code></pre>
<h2 id="多项式-sqrt"><a class="header" href="#多项式-sqrt">多项式 sqrt</a></h2>
<p>令 $A(g) = g^2 - f = 1$，有</p>
<p>$$
\begin{aligned}
g &amp;\equiv g_0 - \frac{g_0^2 - f}{2 g_0} \\
&amp;\equiv \frac{1}{2}(g_0 + f/g_0) \pmod{x^{2n}}
\end{aligned}
$$</p>
<pre><code class="language-cpp">Poly sqrt(int m) const {
    Poly x = {1};
    for (int t = 2; t &lt; m * 2; t *= 2) {
        x = (x + cut(t).div(t, x)) * qpow(2);
    }
    return x.redeg(m);
}
</code></pre>
<h2 id="提示"><a class="header" href="#提示">提示</a></h2>
<p>以上代码真的能跑，时间复杂度 $O(n \log n)$，就是常数比较大。如果被卡常了，请去喷出题人。</p>
<p>还有一些循环卷积优化和分块的常数优化，感兴趣的可以阅读。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://oi-wiki.org/math/poly/newton/">多项式牛顿迭代 - OI Wiki</a></li>
<li><a href="https://negiizhao.blog.uoj.ac/blog/4671">关于优化形式幂级数计算的 Newton 法的常数 - negiizhao</a></li>
<li><a href="https://rogeryoungh.blog.uoj.ac/blog/7530">多项式牛顿迭代的分块优化 - rogeryoungh</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="积性函数"><a class="header" href="#积性函数">积性函数</a></h1>
<p>对于数论函数 $f(x)$​，若对于任意的 $a,b$​ 满足 $a \bot b$​​（即 $a,b$ 互质） 都有</p>
<p>$$
f(ab) = f(a)f(b)
$$</p>
<p>则称 $f(x)$ 为积性函数。</p>
<p>若对任意的 $a,b$ 都有 $f(ab)=f(a)f(b)$，则称 $f(x)$ 为完全积性函数。</p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<p>积性函数的例子有</p>
<ul>
<li>Euler 函数：$\varphi(n) := \sum\limits_{i=1}^n[\gcd(i,n)=1]$。</li>
<li>Mobius 函数：$\mu(n) := \begin{cases}1 &amp; n=1 \\ 0 &amp; \exists d&gt;1,d^{2} \mid n \\ (-1)^{\omega(n)} &amp; \text{otherwise}\end{cases}$</li>
</ul>
<p>完全积性函数的例子有</p>
<ul>
<li>单位函数：$\varepsilon(x) := [x=1]$。</li>
<li>指数函数：$\operatorname{id}_k(x) := x^k$。</li>
<li>常数函数：$1(x) := 1$​。</li>
</ul>
<h2 id="性质-1"><a class="header" href="#性质-1">性质</a></h2>
<p>积性函数与积性函数的卷积是积性函数，积性函数对卷积的逆元也是积性函数，即积性函数的全体构成了一个 Abel 群，其单位元是 $\varepsilon$​。</p>
<p>快速求前缀和，<a href="math/multiplicative-function/../dirichlet/#%E6%9D%9C%E6%95%99%E7%AD%9B">杜教筛</a> 是一种可选的方案。但是其该算法有一些局限性，下面给出几种适用更广泛的快速计算方法。</p>
<ul>
<li>州阁筛。</li>
<li>Min_25 筛。</li>
<li>Powerful Number 筛。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min_25-筛"><a class="header" href="#min_25-筛">Min_25 筛</a></h1>
<p><a href="https://min-25.hatenablog.com/">Min_25</a> 提出了 “Min_25 筛” 。之后，Min_25 还进行了改进，想了解的可以自行了解，这里我们只讲朴素 Min_25 筛。</p>
<p>把质数集记作 $x \notin \mathbb{P}$，第 $i$ 个质数记作 $p_i$。特殊的，$p_0 = 1$。</p>
<p>记 $x$ 的最小非 $1$ 因子为 $\operatorname{lpf}(x)$，显然也是质因子。容易发现，若 $x \notin \mathbb{P}$，则有 $\operatorname{lpf}(x) \leqslant \sqrt{x}$。</p>
<p>记</p>
<p>$$
F(n,k) = \sum_{x=2}^n[p_k &lt; \operatorname{lpf}(x)]f(x)
$$</p>
<p>和</p>
<p>$$
h(n) = \sum_{2 \leqslant p \leqslant n} f(p)
$$</p>
<p>于是 $S(n)$ 可以表示为</p>
<p>$$
\sum_{i=1}^n f(i) = f(1) + F(n, 0)
$$</p>
<p>接下来对各个部分分别求解。</p>
<h3 id="part-1"><a class="header" href="#part-1">Part 1</a></h3>
<p>类似的手法，处理 $F(n,k)$ 函数的计算。</p>
<p>质数单独计算贡献，合数则枚举最小因子 $p_i$，可以得到 $F(n, k)$ 的递推式</p>
<p>$$
\begin{aligned}
F(n, k) &amp; = \sum_{p_k &lt; p_i \leqslant \sqrt{n}} \sum_{p_i^c \leqslant n} f(p_i^c) \left( [c &gt; 1] + \sum_{x = 2}^{\lfloor n/ p_i^c \rfloor} \left[ {p_i}  &lt; \operatorname{lpf} (x) \right] f(x) \right) + \sum_{p_k &lt; p \leqslant n} f(p)\\
&amp; = \sum_{p_k &lt; p_i \leqslant \sqrt{n}} \sum_{p_i^c \leqslant n} f(p_i^c) \left([c &gt; 1] + F \left( \left\lfloor \frac{n}{p_i^c} \right\rfloor, i \right) \right) + h(n) - h (p_k)
\end{aligned}
$$</p>
<p>再注意到，若 $c$ 满足 $p_i^c \leqslant n &lt; p_i^{c + 1}$，可以得到</p>
<p>$$
\left\lfloor \frac{n}{p_i^c} \right\rfloor &lt; p_i &lt; p_{i + 1} \Longrightarrow F \left( \left\lfloor \frac{n}{p_i^c} \right\rfloor, i \right) = 0
$$</p>
<p>而当 $c = 1$ 时第一项 $[c &gt; 1] = 0$，因此可以错开有</p>
<p>$$
F(n, k) = \sum_{p_k &lt; p_i \leqslant \sqrt{n}} \sum_{p_i^{c + 1} \leqslant n} \left(f(p_i^c) g \left( \left\lfloor \frac{n}{p_i^c} \right\rfloor, i \right) + f(p_i^{c + 1}) \right) + h(n) - h (p_i)
$$</p>
<p>如上所述，我们可以写出递归代码。</p>
<pre><code class="language-cpp">Z F(ll u, int k) {
    if (u &lt;= primes[k])
        return 0;
    Z ret = sum[id(u)] - sum[primes[k]];
    for (int i = k + 1; i &lt; primes.size() &amp;&amp; 1ll * primes[i] * primes[i] &lt;= u; i++) {
        ll pi = primes[i], pc = pi;
        for (int c = 1; pc * pi &lt;= u; c++, pc *= pi)
            ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
    }
    return ret;
}
</code></pre>
<h3 id="part-2"><a class="header" href="#part-2">Part 2</a></h3>
<p>接下来，关键在于求 $h$。预处理 $[1,n]$ 所有的 $h$ 不但时间上不够，空间上也不够。注意到我们所有用到的 $h(x)$ 都是 $F(n,0)$ 递归产生的，分类讨论：</p>
<ul>
<li>对于递归产生的 $h(p_i)$，总是有 $p_i \leqslant \sqrt{n}$。</li>
<li>对于递归产生的 $h(n)$，都是通过 $g$ 的递推得到的，是 $n$ 的不断整除。又有定理</li>
</ul>
<p>$$
\left\lfloor \frac{\lfloor a / b \rfloor}{c} \right\rfloor = \left\lfloor \frac{a}{b c} \right\rfloor
$$</p>
<p>这启发我们用整数分块，精简大于 $\sqrt{n}$ 的预处理。</p>
<p>我们只考虑 $f(p)$ 是较低次数的多项式的情况，令 $g_s(p) = p^s$（这样凑出来的 $g$ 是完全积性函数），单独计算每一项后求和。</p>
<p>再联想到 Eratosthenes 筛法：每次枚举一个 $p$，筛去所有不小于 $p^2$ 的 $p$ 的倍数。设第 $k$ 论筛完后剩下的数的 $g(p)$ 之和为</p>
<p>$$
G_k(n) = \sum_{i = 2}^n [p_k &lt; \operatorname{lpf} (i) \vee i \in \mathbb{P}] g(i)
$$</p>
<p>容易发现，当 $n &lt; p_k^2$ 时，$G_k(n) = G_{k - 1}(n)$。当 $n \geqslant p_i^2$ 时，递推有</p>
<p>$$
G_k(n) = G_{k - 1}(n) - g(p_k) \left( G_{k - 1} \left( \left\lfloor \frac{n}{p_k} \right\rfloor \right) - G_{i - 1} (p_k - 1) \right)
$$</p>
<p>至此，我们完成了朴素 Min_25 筛的全部推导。</p>
<h3 id="例题-8"><a class="header" href="#例题-8">例题</a></h3>
<div id="admonition-loj6053-简单的函数httpslojacp6053" class="admonition note">
<div class="admonition-title">
<p><a href="https://loj.ac/p/6053">LOJ6053 简单的函数</a></p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-loj6053-简单的函数httpslojacp6053"></a></p>
</div>
<div>
<p>给定一个积性函数 $f(x)$，其中：</p>
<ol>
<li>$f(p^c) = p \oplus c$。</li>
<li>$f(1) = 1$。</li>
</ol>
<p>求其前缀和。</p>
</div>
</div>
<p>因为 $f(p) = p - 1 + 2 [p = 2]$，拆分成 $p$ 和 $-1$ 即可，注意最后需要加 $2$。</p>
<details id="admonition-参考代码" class="admonition info">
<summary class="admonition-title">
<p>参考代码</p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-参考代码"></a></p>
</summary>
<div>
<pre><code class="language-cpp">struct Min25 {
    ll n, sn, m = 0;
    vector&lt;int&gt; primes;
    vector&lt;Z&gt; sum;
    Z fp(int p, int k) {
        return p ^ k;
    }
    int id(ll x) {
        return x &lt;= sn ? x : m - (n / x) + 1;
    }
    Min25(ll u) : n(u), sn(sqrt(n) + 1), sum(sn * 2 + 5) {
        vector&lt;bool&gt; not_p(sn + 1);
        vector&lt;ll&gt; w(sn * 2 + 5);
        for (ll l = 1, r; l &lt;= n; l = r + 1) {
            w[++m] = r = n / (n / l);
        }
        vector&lt;Z&gt; s0(m + 1), s1(m + 1);
        for (int i = 1; i &lt;= m; i++) {
            Z r = w[i] % P;
            s0[i] = r - 1;
            s1[i] = r * (r + 1) / 2 - 1;
        }
        primes.push_back(0);
        for (int i = 2; i &lt;= sn; i++) {
            if (not not_p[i]) {
                primes.push_back(i);
                for (int j = i; j &lt;= (sn - 1) / i; j++)
                    not_p[i * j] = true;
                for (int j = m; w[j] &gt;= 1ll * i * i; j--) {
                    s1[j] -= i * (s1[id(w[j] / i)] - s1[i - 1]);
                    s0[j] -= s0[id(w[j] / i)] - s0[i - 1];
                }
            }
        }
        for (int i = 2; i &lt;= m; i++) {
            sum[i] = s1[i] - s0[i] + 2;
        }
    }
    Z eval() {
        return F(n, 0) + 1;
    }
    Z F(ll u, int k) {
        if (u &lt;= primes[k])
            return 0;
        Z ret = sum[id(u)] - sum[primes[k]];
        for (int i = k + 1; i &lt; primes.size() &amp;&amp; 1ll * primes[i] * primes[i] &lt;= u; i++) {
            ll pi = primes[i], pc = pi;
            for (int c = 1; pc * pi &lt;= u; c++, pc *= pi)
                ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
        }
        return ret;
    }
};
</code></pre>
</div>
</details>
<div id="admonition-p5325-min25-筛httpswwwluogucomcnproblemp5325" class="admonition note">
<div class="admonition-title">
<p><a href="https://www.luogu.com.cn/problem/P5325">P5325 Min25 筛</a></p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-p5325-min25-筛httpswwwluogucomcnproblemp5325"></a></p>
</div>
<div>
<p>给定一个积性函数 $f(x)$，其中：</p>
<ol>
<li>$f(p^c) = p^c(p^c - 1)$。</li>
<li>$f(1) = 1$。</li>
</ol>
<p>求其前缀和，答案对 $10^9+7$ 取模。</p>
</div>
</div>
<p>注意到 $f(p) = p^2 - p$，拆分成 $p^2$ 和 $p$ 即可。</p>
<details id="admonition-参考代码-1" class="admonition info">
<summary class="admonition-title">
<p>参考代码</p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-参考代码-1"></a></p>
</summary>
<div>
<pre><code class="language-cpp">struct Min25 {
    ll n, sn, m = 0;
    vector&lt;int&gt; primes;
    vector&lt;Z&gt; sum;
    Z fp(int p, int k) {
        Z pk = Z(p).pow(k);
        return pk * (pk - 1);
    }
    int id(ll x) {
        return x &lt;= sn ? x : m - (n / x) + 1;
    }
    Min25(ll u) : n(u), sn(sqrt(n) + 1), sum(sn * 2 + 5) {
        vector&lt;bool&gt; not_p(sn + 1);
        vector&lt;ll&gt; w(sn * 2 + 5);
        for (ll l = 1, r; l &lt;= n; l = r + 1) {
            w[++m] = r = n / (n / l);
        }
        vector&lt;Z&gt; s2(m + 1), s1(m + 1);
        for (int i = 1; i &lt;= m; i++) {
            Z r = w[i] % P;
            s1[i] = r * (r + 1) / 2 - 1;
            s2[i] = r * (r + 1) * (2 * r + 1) / 6 - 1;
        }
        primes.push_back(0);
        for (int i = 2; i &lt;= sn; i++) {
            if (not not_p[i]) {
                primes.push_back(i);
                for (int j = i; j &lt;= (sn - 1) / i; j++)
                    not_p[i * j] = true;
                for (int j = m; w[j] &gt;= 1ll * i * i; j--) {
                    s1[j] -= i * (s1[id(w[j] / i)] - s1[i - 1]);
                    s2[j] -= Z(i) * i * (s2[id(w[j] / i)] - s2[i - 1]);
                }
            }
        }
        for (int i = 2; i &lt;= m; i++) {
            sum[i] = s2[i] - s1[i];
        }
    }
    Z eval() {
        return F(n, 0) + 1;
    }
    Z F(ll u, int k) {
        if (u &lt;= primes[k])
            return 0;
        Z ret = sum[id(u)] - sum[primes[k]];
        for (int i = k + 1; i &lt; primes.size() &amp;&amp; 1ll * primes[i] * primes[i] &lt;= u; i++) {
            ll pi = primes[i], pc = pi;
            for (int c = 1; pc * pi &lt;= u; c++, pc *= pi)
                ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
        }
        return ret;
    }
};
</code></pre>
</div>
</details>
<div id="admonition-p4213-杜教筛httpswwwluogucomcnproblemp4213" class="admonition note">
<div class="admonition-title">
<p><a href="https://www.luogu.com.cn/problem/P4213">P4213 杜教筛</a></p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-p4213-杜教筛httpswwwluogucomcnproblemp4213"></a></p>
</div>
<div>
<p>求积性函数 $\varphi(x)$ 和 $\mu(x)$ 的前缀和</p>
<ol>
<li>$\varphi(p^c) = p^c - p^{c-1}$。</li>
<li>$\mu(p^c) = -[c=1]$。</li>
</ol>
</div>
</div>
<p>因为 $\varphi(p) = p - 1$，和 $\mu(p) = -1$，处理上大同小异。</p>
<details id="admonition-参考代码-2" class="admonition info">
<summary class="admonition-title">
<p>参考代码</p>
<p><a class="admonition-anchor-link" href="math/multiplicative-function/min25.html#admonition-参考代码-2"></a></p>
</summary>
<div>
<pre><code class="language-cpp">struct Min25_phi {
    ll n, sn, m = 0;
    vector&lt;int&gt; primes;
    vector&lt;Z&gt; sum;
    Z fp(int p, int k) {
        return qpow(p, k - 1) * (p - 1);
    }
    int id(ll x) {
        return x &lt;= sn ? x : m - (n / x) + 1;
    }
    Min25_phi(ll u) : n(u), sn(sqrt(n) + 1), sum(sn * 2 + 5) {
        vector&lt;bool&gt; not_p(sn + 1);
        vector&lt;ll&gt; w(sn * 2 + 5);
        for (ll l = 1, r; l &lt;= n; l = r + 1) {
            w[++m] = r = n / (n / l);
        }
        vector&lt;Z&gt; s0(m + 1), s1(m + 1);
        for (int i = 1; i &lt;= m; i++) {
            Z r = w[i];
            s0[i] = r - 1;
            s1[i] = r * (r + 1) / 2 - 1;
        }
        primes.push_back(0);
        for (int i = 2; i &lt;= sn; i++) {
            if (not not_p[i]) {
                primes.push_back(i);
                for (int j = i; j &lt;= (sn - 1) / i; j++)
                    not_p[i * j] = true;
                for (int j = m; w[j] &gt;= 1ll * i * i; j--) {
                    s1[j] -= i * (s1[id(w[j] / i)] - s1[i - 1]);
                    s0[j] -= s0[id(w[j] / i)] - s0[i - 1];
                }
            }
        }
        for (int i = 2; i &lt;= m; i++) {
            sum[i] = s1[i] - s0[i];
        }
    }
    Z eval() {
        return F(n, 0) + 1;
    }
    Z F(ll u, int k) {
        if (u &lt;= primes[k])
            return 0;
        Z ret = sum[id(u)] - sum[primes[k]];
        for (int i = k + 1; i &lt; primes.size() &amp;&amp; 1ll * primes[i] * primes[i] &lt;= u; i++) {
            ll pi = primes[i], pc = pi;
            for (int c = 1; pc * pi &lt;= u; c++, pc *= pi) {
                ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
            }
        }
        return ret;
    }
};

struct Min25_mu {
    ll n, sn, m = 0;
    vector&lt;int&gt; primes;
    vector&lt;Z&gt; sum;
    Z fp(int p, int k) {
        return -(k == 1);
    }
    int id(ll x) {
        return x &lt;= sn ? x : m - (n / x) + 1;
    }
    Min25_mu(ll u) : n(u), sn(sqrt(n) + 1), sum(sn * 2 + 5) {
        vector&lt;bool&gt; not_p(sn + 1);
        vector&lt;ll&gt; w(sn * 2 + 5);
        for (ll l = 1, r; l &lt;= n; l = r + 1) {
            w[++m] = r = n / (n / l);
        }
        vector&lt;Z&gt; s0(m + 1);
        for (int i = 1; i &lt;= m; i++) {
            Z r = w[i];
            s0[i] = r - 1;
        }
        primes.push_back(0);
        for (int i = 2; i &lt;= sn; i++) {
            if (not not_p[i]) {
                primes.push_back(i);
                for (int j = i; j &lt;= (sn - 1) / i; j++)
                    not_p[i * j] = true;
                for (int j = m; w[j] &gt;= 1ll * i * i; j--) {
                    s0[j] -= s0[id(w[j] / i)] - s0[i - 1];
                }
            }
        }
        for (int i = 2; i &lt;= m; i++) {
            sum[i] = -s0[i];
        }
    }
    Z eval() {
        return F(n, 0) + 1;
    }
    Z F(ll u, int k) {
        if (u &lt;= primes[k])
            return 0;
        Z ret = sum[id(u)] - sum[primes[k]];
        for (int i = k + 1; i &lt; primes.size() &amp;&amp; 1ll * primes[i] * primes[i] &lt;= u; i++) {
            ll pi = primes[i], pc = pi;
            for (int c = 1; pc * pi &lt;= u; c++, pc *= pi)
                ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
        }
        return ret;
    }
};
</code></pre>
</div>
</details>
<h2 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://oi-wiki.org/math/number-theory/min-25/">Min_25 筛 - OI Wiki</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="舟阁筛"><a class="header" href="#舟阁筛">舟阁筛</a></h1>
<p>设 $n$ 的唯一分解是</p>
<p>$$
n = p_1^{k_1} p_2^{k_2} \cdots p_s^{k_s}
$$</p>
<p>则积性函数 $f(x)$​​​ 的在 $x=n$ 处的值有</p>
<p>$$
f(n) = f(p_1^{k_1}) f(p_2^{k_2}) \cdots f(p_s^{k_s})
$$</p>
<p>由于数 $i$ 最多只能拥有一个大于 $\sqrt{n}$​ 的因子，因此按照是否具有分类，可以得到</p>
<p>$$
\begin{aligned}
\sum_{i=1}^nf(i) &amp;= \sum_{\begin{subarray}{c}
x \leqslant n \\ x {\rm \ 无大于\ } \sqrt{n} {\rm \ 的质因子}
\end{subarray}}
\left[ f(x) \left( 1 + \sum_{\sqrt{n} &lt; p \leqslant \lfloor n/x \rfloor} f(p) \right)\right] \\
&amp;= \sum_{x=1}^{\sqrt{n}} f(x)\sum_{p &gt; \sqrt{n}}^{\lfloor n/x \rfloor} f(p) + 
\sum_{\begin{subarray}{c}
x \leqslant n\\x {\rm \ 无大于\ } \sqrt{n} {\rm \ 的质因子}
\end{subarray}} f(x)
\end{aligned}
$$</p>
<p>关键就在如何快速求这几部分。</p>
<h3 id="part-1-1"><a class="header" href="#part-1-1">Part 1</a></h3>
<p>考虑记 $[1,l]$ 中不含因子 $p_1,\cdots,p_t$ 的数在 $f$ 下取值之和为 $g(t,l)$。递推关系有</p>
<p>$$
g(t,j) = g(t-1, j) - f(p_t) g(t-1, \lfloor l/p_t \rfloor)
$$</p>
<p>边界为 $g(0,l) = \sum\limits_{i=1}^l f(i)$​。设 $[1,\sqrt{n}]$​ 内质数的个数为 $m$，因此第一部分即化为计算</p>
<p>$$
\sum_{x=1}^{\sqrt{n}} f(x)\sum_{p &gt; \sqrt{n}}^{\lfloor n/x \rfloor} f(p) = \sum_{x=1}^{\sqrt{n}} f(x) g(m, \lfloor n/x \rfloor)
$$</p>
<p>然而朴素的预处理 $g$ 的复杂度是 $O\left( \dfrac{n}{\log n} \right)$​，需要再优化。</p>
<p>容易发现当 $p_{t+1} &gt; l$ 时有 $g(t,l) = f(1) = 1$。故当 $p_t^2 &gt; l$ 时，代入递推有</p>
<p>$$
g(t,l) = g(t-1, j) - f(p_t)
$$</p>
<p>因此 $p_t^2 &gt; j$​ 时的计算是可以省去的，直接累加这一段质数取值即可。此时复杂度 $O\left( \dfrac{n^{\frac{3}{4}}}{\log n} \right)$​​。</p>
<h3 id="part-2-1"><a class="header" href="#part-2-1">Part 2</a></h3>
<p>再考虑记 $[1,l]$ 中只含因子 $p_t,\cdots,p_m$ 的数在 $f$​ 下取值之和为 $h(t,l)$​。递推有</p>
<p>$$
h(t,l) = h(t+1, l) + \sum_{c=1} f(p_t^c) h(t+1, \lfloor l/p_t^c \rfloor)
$$</p>
<p>其边界条件为 $h(m+1, l) = f(1) = 1$​。于是</p>
<p>$$
\sum_{\begin{subarray}{c}
x \leqslant n\\x {\rm \ 无大于\ } \sqrt{n} {\rm \ 的质因子}
\end{subarray}} f(x) = h(0, n)
$$</p>
<p>类似的优化 $h$ 的计算。当 $p_t &gt; l$ 时有 $h(t,l) = f(1) = 1$，代入递推，当 $p_t^2 &gt; l$ 时有</p>
<p>$$
h(t,l) = h(t-1,l) + f(p_t)
$$</p>
<p>同样直接累加。此处复杂度 $O\left( \dfrac{n^{\frac{3}{4}}}{\log n} \right)$​​。</p>
<h3 id="all"><a class="header" href="#all">All</a></h3>
<p>总复杂度 $O\left( \dfrac{n^{\frac{3}{4}}}{\log n} \right)$。我们要求 $f(p)$​ 是容易计算的，否则其会增加额外的损耗。</p>
<p>州阁筛似乎后面又进行了一些进化，能够达到更优的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="powerful-number-筛"><a class="header" href="#powerful-number-筛">Powerful Number 筛</a></h1>
<p>对于数 $n$，记其质因分解为</p>
<p>$$
n = \prod_{i=1}^k p_i^{c_i}
$$</p>
<p>若其所有幂次都大于 $1$，即 $c_i &gt; 1$，则称 $n$ 为 Powerful Number，简称 PN。</p>
<h2 id="性质-2"><a class="header" href="#性质-2">性质</a></h2>
<p>若 $n$ 是 PN，则 $n$ 总是可以表示成 $a^2b^3$ 的形式。</p>
<p>$n$ 以内 PN 的个数是 $O(\sqrt{n})$ 的。</p>
<h2 id="计算"><a class="header" href="#计算">计算</a></h2>
<p>考虑构造一个易于求和的函数 $g$，其在 $p$ 处有 $g(p) = f(p)$。</p>
<p>之后，构造 $h = f \ast g^{-1}$，不难计算得到</p>
<p>$$
f(p) - g(p) = g(p)h(1) + h(p)g(1) - g(p) = h(p) = 0
$$</p>
<p>因此 $h$ 只在 PN 处有值。由杜教筛可以得到：</p>
<p>$$
\begin{aligned}
\sum_{i=1}^n f(i) &amp;= \sum_{i=1}^n (g \ast h)(i) \\
&amp;= \sum_{d = 1}^n h(d) \sum_{i=1}^{\lfloor n/d \rfloor} g(i) \\
&amp;= G(n) + \sum_{d \in {\mathrm{PN}}} h(d) G(\lfloor n/d \rfloor)
\end{aligned}
$$</p>
<p>若 $G(n)$ 可以通过杜教筛等方式快速求和，那么上式就可以快速计算。</p>
<p>对于 $h(p^c)$，可以直接计算，又因为因为质数的幂次不会很大，直接卷积也可以。</p>
<p>对 PN 的搜索可以简单的直接 DFS。</p>
<h2 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://oi-wiki.org/math/number-theory/powerful-number/">Powerful Number 筛</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<p>树状数组可以实现</p>
<ul>
<li>将某一个数加上 $x$</li>
<li>求出某区间每一个数的和</li>
</ul>
<p>树状数组只能维护运算的前缀和，当逆元存在时才能得到区间的信息。比如取 $\max$，其逆运算不存在的时候只能写线段树了。</p>
<h2 id="单点增加区间求和"><a class="header" href="#单点增加区间求和">单点增加，区间求和</a></h2>
<p>建树只需要 $O(n)$。</p>
<pre><code class="language-cpp">void build() {
    for (int i = 1; i &lt;=n; i++) {
        cc[i] += aa[i];
        int j = i + (i&amp;(-i));
        if(j &lt;= n)
            cc[j] += cc[i];
    }
}
</code></pre>
<p>查询前缀和 $[1,x]$。</p>
<pre><code class="language-cpp">int ask(int *cc, int x) {
    int sum = 0;
    while (x &gt;= 1) {
        sum += cc[x];
        x -= x&amp;(-x);
    }
    return sum;
}
</code></pre>
<p>单点增加，在 $x$ 点处增加 $k$。</p>
<pre><code class="language-cpp">void add(int *cc, int x, int k) {
    while (x &lt;= n) {
        cc[x] += k;
        x += x&amp;(-x);
    }
}
</code></pre>
<h2 id="区间加--单点查询"><a class="header" href="#区间加--单点查询">区间加 &amp; 单点查询</a></h2>
<p>维护数组 $a$ 的额外差分数组 $b$，区间加就被转化为 $b$ 的单点增加，单点查询就被转化为 $b$ 的区间查询。</p>
<pre><code class="language-cpp">int bb[MAXN];

void badd(int l, int r, int k) {
    add(bb, l, k);
    add(bb, r+1, -k);
}

int bask(int x) {
    return ask(bb, x) + aa[x];
}
</code></pre>
<h2 id="区间加--区间求和"><a class="header" href="#区间加--区间求和">区间加 &amp; 区间求和</a></h2>
<p>维护数组 $a$ 的额外差分数组 $b$，当我们对 $a$ 的前缀 $r$ 求和时有</p>
<p>$$
\sum_{i=1}^r \sum_{j=1}^i b_j = \sum_{i=1}^rb_i(r-i+1) = (r+1)\sum_{i=1}^rb_i - \sum_{i=1}^rb_ii
$$</p>
<p>因此还需要两个树状数组来维护 $\sum b_i$ 和 $\sum b_ii$。查询前缀和 <code>cask</code>。</p>
<pre><code class="language-cpp">int bb1[MAXN], bb2[MAXN];

void cadd(int l, int r, int k) {
    add(bb1, l, k);
    add(bb1, r+1, -k);
    add(bb2, l, l * k);
    add(bb2, r+1, -(r+1) * k);
}

int cask(int x) {
    return (x+1) * ask(bb1, x) + ask(cc,x) - ask(bb2,x);
}
</code></pre>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<ul>
<li><a href="https://loj.ac/problem/130">L130 树状数组 1：单点修改，区间查询</a></li>
<li><a href="https://loj.ac/problem/131">L131 树状数组 2：区间修改，单点查询</a></li>
<li><a href="https://loj.ac/problem/132">L132 树状数组 3：区间修改，区间查询</a></li>
<li><a href="https://loj.ac/problem/133">L133 二维树状数组 1：单点修改，区间查询</a></li>
<li><a href="https://loj.ac/problem/135">L135 二维树状数组 3：区间修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st-表"><a class="header" href="#st-表">ST 表</a></h1>
<p>ST 表基于倍增思想，可以做到 $O(n\log n)$ 预处理，$O(1)$ 回答每个询问，所用空间为 $O(n\log n)$。</p>
<p>ST 表仅适用于 <strong>可重复贡献问题</strong> 问题。</p>
<blockquote>
<p><strong>什么是可重复贡献问题</strong> </p>
<p>对于运算 $\ast$，满足结合律且 $x \ast x = x$，则对应的区间询问就是一个可重复贡献问题。例如 $\max(x,x),\gcd(x,x)$。像区间和就不具有这个性质。</p>
</blockquote>
<p>令 $ST(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值，显然 $ST(i,0)=a_i$。</p>
<p>熟悉 C++ 的同学可能知道，<code>std::__lg</code> 可以 $O(1)$ 的计算 $\log_2$，不再需要预处理。</p>
<p>以 $\max$ 为例，我们可以列出状态转移方程</p>
<p>$$
ST(i,j+1) = \max\{ST(i,j) , ST(i+2^{j},j)\}
$$</p>
<p>于是可以写出代码</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= n; i++) {
    st[0][i] = a[i];
}
for (int j = 1; j &lt;= std::__lg(n); j++) {
    int tj = 1 &lt;&lt; (j - 1), ti = n - tj * 2 + 1;
    for (int i = 1; i &lt;= ti; i++) {
        st[j][i] = max(st[j - 1][i], st[j - 1][i + tj]);
    }
}
</code></pre>
<p>记 $s = \lfloor\log_2(r-l+1)\rfloor$，我们总是可以用两个区间 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 来覆盖所查询区间。</p>
<pre><code class="language-cpp">int query(int x, int y) {
    int s = std::__lg(y - x + 1);
    return max(st[s][x], st[s][y - (1 &lt;&lt; s) + 1]);
}
</code></pre>
<h2 id="练习-4"><a class="header" href="#练习-4">练习</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 【模板】ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小表示法"><a class="header" href="#最小表示法">最小表示法</a></h1>
<p>若长为 $n$ 的字符串可以选择一个位置 $i$ 使得</p>
<p>$$
S[i \ldots n - 1] + S[0 \ldots i - 1] = T
$$</p>
<p>则称 $S$ 与 $T$ 循环同构。求与 $S$ 循环同构的所有字符串中字典序最小的字符串。</p>
<h2 id="原理-4"><a class="header" href="#原理-4">原理</a></h2>
<p>不妨记前面的串为 $S_i$。暴力是显然的，枚举所有 $S_i$ 和 $S_j$ 并逐位比较，选择更大的。</p>
<pre><code class="language-cpp">int k = 0, i = 0, j = 1;
while (k &lt; len &amp;&amp; i &lt; len &amp;&amp; j &lt; len) {
    if (S[(i + k) % len] == S[(j + k) % len]) {
        ++k;
    } else {
        if (S[(i + k) % len] &gt; S[(j + k) % len])
            i++;
        else
            j++;
        if (i == j)
            i++;
        k = 0;
    }
}
return min(i, j);
</code></pre>
<p>该算法在特殊情况下的最差复杂度是 $O(n^2)$。我们需要想办法优化。</p>
<p>假设当比对到第 $k + 1$ 位时有 $S_i[k] &gt; S_j[k]$，并且前面的位也都相同。注意到在 $1 \leqslant p \leqslant k$ 时有</p>
<p>$$
S_{i+p}[k-p] &gt; S_{j+p}[k-p]
$$</p>
<p>这意味对于 $S_{j+p}$ 始终是比 $S_{i+p}$ 更优的解。因此可以直接跳到 $S_{j+k+1}$。</p>
<pre><code class="language-cpp">int k = 0, i = 0, j = 1;
while (k &lt; len &amp;&amp; i &lt; len &amp;&amp; j &lt; len) {
    if (S[(i + k) % len] == S[(j + k) % len]) {
        ++k;
    } else {
        if (S[(i + k) % len] &gt; S[(j + k) % len])
            i = i + k + 1;
        else
            j = j + k + 1;
        if (i == j)
            i++;
        k = 0;
    }
}
return min(i, j);
</code></pre>
<h2 id="习题"><a class="header" href="#习题">习题</a></h2>
<p><a href="https://www.luogu.com.cn/problem/P1368">P1368 最小表示法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown-介绍"><a class="header" href="#markdown-介绍">Markdown 介绍</a></h1>
<p>我推荐 Markdown，因为它足够流行，足够简单。</p>
<p>本文讲介绍一些 Markdown 的基础文法，MkDocs 独有的特性请阅读 <a href="other/mkdocs.html">MkDocs</a>。</p>
<p>更详细的请阅读 <a href="https://cyent.github.io/markdown-with-mkdocs-material/syntax/main/">Cyent</a>。</p>
<h2 id="markdown-适合"><a class="header" href="#markdown-适合">Markdown 适合</a></h2>
<p>Markdown 是 HTML 的简单替代，是一个纯文本文件。它适合于撰写网络文章，通常这些文章只需要很少的格式。</p>
<p>Markdown 不适合做复杂的排版工作，它不能精确的控制文本的样式。</p>
<h2 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h2>
<p>支持 Markdown 的编辑器很多。我推荐 <a href="https://code.visualstudio.com/">VSCode</a>，它是一个通用而强大的编辑器，或者尝试 <a href="https://typora.io/">Typora</a> ，它一个所见即所得的 Markdown 编辑器。</p>
<p>或者你不愿意下载，你可以在线尝试 <a href="https://www.zybuluo.com/mdeditor">CMD 作业部落</a>。</p>
<h2 id="标题与段落"><a class="header" href="#标题与段落">标题与段落</a></h2>
<p>标题使用 <code>#</code> 符号，空格后接文本。</p>
<pre><code class="language-md"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题

普通段落。
</code></pre>
<p>普通段落，每两段之间空一行。</p>
<pre><code class="language-md">其它格式有 **粗体** 和 *斜体*，
段间记得空行，否则不会换行的。

还有 &lt;u&gt;下划线&lt;/u&gt; 和 &lt;del&gt;删除线&lt;/del&gt;，和 ==高亮== 。
</code></pre>
<p>其它格式有 <strong>粗体</strong> 和 <em>斜体</em>，
段间记得空行，否则不会换行的。</p>
<p>还有 <u>下划线</u> 和 <del>删除线</del>，和 ==高亮== 。</p>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<pre><code class="language-md">&gt; 这里是引用
&gt;
&gt; &gt; 二级引用。
</code></pre>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<pre><code class="language-md">内联代码 `var example = true`，按键 &lt;kbd&gt;Ctrl&lt;/kbd&gt;
</code></pre>
<p>代码块后跟语言以使用代码高亮。按键 <kbd>Ctrl</kbd></p>
<pre><code>```rust
fn main() {
    println!(&quot;Hello World!&quot;);
}
```
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>pygments 支持 434 种语言的高亮，你可以在 <a href="https://cyent.github.io/markdown-with-mkdocs-material/appendix/pygments/">这里</a> 找到它们。</p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<p>无序列表</p>
<pre><code class="language-md">* Item 1
* Item 2
  * Item 2a
  * Item 2b
</code></pre>
<p>有序列表，点号与文本间需要加空格。可以全写 1 来自动编号。</p>
<pre><code class="language-md">1. Item 1
1. Item 2
1. Item 3
  1. Item 3a
  1. Item 3b
</code></pre>
<p>任务列表，注意缩进空格是 4 个。</p>
<pre><code class="language-md">- [x] Item 1
- [ ] Item 2
    - [ ] Item 2a
    - [x] Item 2b
</code></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Item 1</li>
<li><input disabled="" type="checkbox"/>
Item 2
<ul>
<li><input disabled="" type="checkbox"/>
Item 2a</li>
<li><input disabled="" type="checkbox" checked=""/>
Item 2b</li>
</ul>
</li>
</ul>
<h2 id="图片与链接"><a class="header" href="#图片与链接">图片与链接</a></h2>
<pre><code class="language-md">图片      ![](图片链接地址)
链接      [链接文字](链接地址)
</code></pre>
<p>文档之间的交叉链接，填相对地址。</p>
<h2 id="latex-公式"><a class="header" href="#latex-公式">LaTeX 公式</a></h2>
<p>很多同学应该会使用 $\rm\LaTeX$，因此我启用了 MathJax 扩展，可以在文章中穿插公式。比如 $a^2+b^2=c^2$，</p>
<p>$$
\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}
$$</p>
<pre><code class="language-latex">比如 $a^2+b^2=c^2$，

$$
\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}
$$
</code></pre>
<p>深入 $\rm\LaTeX$ 超出了我们的讨论范围，请您自行了解。</p>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<p>冒号在哪边表示向哪边对齐，默认是左对齐，两边都有则居中。</p>
<pre><code class="language-md">| Tables        | Are           | Cool   |
| ------------- |:-------------:| ------:|
| col 3 is      | right-aligned | \$1600 |
| col 2 is      | centered      |   \$12 |
| zebra stripes | are neat      |    \$1 |
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Tables</th><th style="text-align: center">Are</th><th style="text-align: right">Cool</th></tr></thead><tbody>
<tr><td>col 3 is</td><td style="text-align: center">right-aligned</td><td style="text-align: right">$1600</td></tr>
<tr><td>col 2 is</td><td style="text-align: center">centered</td><td style="text-align: right">\$12</td></tr>
<tr><td>zebra stripes</td><td style="text-align: center">are neat</td><td style="text-align: right">$1</td></tr>
</tbody></table>
</div>
<h2 id="脚注"><a class="header" href="#脚注">脚注</a></h2>
<pre><code class="language-md">脚注 [^1] 会自动放到文末。 

[^1]: footnote，脚注
</code></pre>
<p>脚注 <sup class="footnote-reference"><a href="#1">1</a></sup> 会自动放到文末。 </p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>footnote，脚注</p>
</div>
<h2 id="转义"><a class="header" href="#转义">转义</a></h2>
<p>复杂的格式自然会有转义，如下特殊字符需要通过前加 <code>\</code> 转义。有些时候不加也可以</p>
<pre><code class="language-md">\ backslash
` backtick
\* asterisk
\_ underscore
{} curly braces
[] square brackets
() parentheses
# hash mark
+ plus sign
- minus sign (hyphen)
. dot
! exclamation mark
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
